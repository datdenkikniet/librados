/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _NETINET_IN_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 42;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOL_VSOCK: u32 = 287;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_PASSPIDFD: u32 = 76;
pub const SO_PEERPIDFD: u32 = 77;
pub const SO_DEVMEM_LINEAR: u32 = 78;
pub const SCM_DEVMEM_LINEAR: u32 = 78;
pub const SO_DEVMEM_DMABUF: u32 = 79;
pub const SCM_DEVMEM_DMABUF: u32 = 79;
pub const SO_DEVMEM_DONTNEED: u32 = 80;
pub const SCM_TS_OPT_ID: u32 = 81;
pub const SO_RCVPRIORITY: u32 = 82;
pub const SO_PASSRIGHTS: u32 = 83;
pub const SO_INQ: u32 = 84;
pub const SCM_INQ: u32 = 84;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_LOCAL_PORT_RANGE: u32 = 51;
pub const IP_PROTOCOL: u32 = 52;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _STRING_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const LIBRADOS_ALL_NSPACES: &[u8; 2] = b"\x01\0";
pub const _SYS_TIME_H: u32 = 1;
pub const CEPH_OSD_TMAP_HDR: u8 = 104u8;
pub const CEPH_OSD_TMAP_SET: u8 = 115u8;
pub const CEPH_OSD_TMAP_CREATE: u8 = 99u8;
pub const CEPH_OSD_TMAP_RM: u8 = 114u8;
pub const LIBRADOS_VER_MAJOR: u32 = 3;
pub const LIBRADOS_VER_MINOR: u32 = 0;
pub const LIBRADOS_VER_EXTRA: u32 = 0;
pub const LIBRADOS_SUPPORTS_WATCH: u32 = 1;
pub const LIBRADOS_SUPPORTS_SERVICES: u32 = 1;
pub const LIBRADOS_SUPPORTS_GETADDRS: u32 = 1;
pub const LIBRADOS_SUPPORTS_APP_METADATA: u32 = 1;
pub const LIBRADOS_LOCK_FLAG_RENEW: u32 = 1;
pub const LIBRADOS_LOCK_FLAG_MAY_RENEW: u32 = 1;
pub const LIBRADOS_LOCK_FLAG_MUST_RENEW: u32 = 2;
pub const LIBRADOS_CREATE_EXCLUSIVE: u32 = 1;
pub const LIBRADOS_CREATE_IDEMPOTENT: u32 = 0;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iovec"][::std::mem::size_of::<iovec>() - 16usize];
    ["Alignment of iovec"][::std::mem::align_of::<iovec>() - 8usize];
    ["Offset of field: iovec::iov_base"][::std::mem::offset_of!(iovec, iov_base) - 0usize];
    ["Offset of field: iovec::iov_len"][::std::mem::offset_of!(iovec, iov_len) - 8usize];
};
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
    pub __unused_initialized_1: ::std::os::raw::c_uint,
    pub __unused_initialized_2: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 16usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 28usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 32usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_1"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_1) - 40usize];
    ["Offset of field: __pthread_cond_s::__unused_initialized_2"]
        [::std::mem::offset_of!(__pthread_cond_s, __unused_initialized_2) - 44usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr"][::std::mem::size_of::<sockaddr>() - 16usize];
    ["Alignment of sockaddr"][::std::mem::align_of::<sockaddr>() - 2usize];
    ["Offset of field: sockaddr::sa_family"][::std::mem::offset_of!(sockaddr, sa_family) - 0usize];
    ["Offset of field: sockaddr::sa_data"][::std::mem::offset_of!(sockaddr, sa_data) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_storage"][::std::mem::size_of::<sockaddr_storage>() - 128usize];
    ["Alignment of sockaddr_storage"][::std::mem::align_of::<sockaddr_storage>() - 8usize];
    ["Offset of field: sockaddr_storage::ss_family"]
        [::std::mem::offset_of!(sockaddr_storage, ss_family) - 0usize];
    ["Offset of field: sockaddr_storage::__ss_padding"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_padding) - 2usize];
    ["Offset of field: sockaddr_storage::__ss_align"]
        [::std::mem::offset_of!(sockaddr_storage, __ss_align) - 120usize];
};
pub const MSG_OOB: _bindgen_ty_1 = 1;
pub const MSG_PEEK: _bindgen_ty_1 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_1 = 4;
pub const MSG_CTRUNC: _bindgen_ty_1 = 8;
pub const MSG_PROXY: _bindgen_ty_1 = 16;
pub const MSG_TRUNC: _bindgen_ty_1 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_1 = 64;
pub const MSG_EOR: _bindgen_ty_1 = 128;
pub const MSG_WAITALL: _bindgen_ty_1 = 256;
pub const MSG_FIN: _bindgen_ty_1 = 512;
pub const MSG_SYN: _bindgen_ty_1 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_1 = 2048;
pub const MSG_RST: _bindgen_ty_1 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = 16384;
pub const MSG_MORE: _bindgen_ty_1 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_1 = 65536;
pub const MSG_BATCH: _bindgen_ty_1 = 262144;
pub const MSG_SOCK_DEVMEM: _bindgen_ty_1 = 33554432;
pub const MSG_ZEROCOPY: _bindgen_ty_1 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_1 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = 1073741824;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of msghdr"][::std::mem::size_of::<msghdr>() - 56usize];
    ["Alignment of msghdr"][::std::mem::align_of::<msghdr>() - 8usize];
    ["Offset of field: msghdr::msg_name"][::std::mem::offset_of!(msghdr, msg_name) - 0usize];
    ["Offset of field: msghdr::msg_namelen"][::std::mem::offset_of!(msghdr, msg_namelen) - 8usize];
    ["Offset of field: msghdr::msg_iov"][::std::mem::offset_of!(msghdr, msg_iov) - 16usize];
    ["Offset of field: msghdr::msg_iovlen"][::std::mem::offset_of!(msghdr, msg_iovlen) - 24usize];
    ["Offset of field: msghdr::msg_control"][::std::mem::offset_of!(msghdr, msg_control) - 32usize];
    ["Offset of field: msghdr::msg_controllen"]
        [::std::mem::offset_of!(msghdr, msg_controllen) - 40usize];
    ["Offset of field: msghdr::msg_flags"][::std::mem::offset_of!(msghdr, msg_flags) - 48usize];
};
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cmsghdr"][::std::mem::size_of::<cmsghdr>() - 16usize];
    ["Alignment of cmsghdr"][::std::mem::align_of::<cmsghdr>() - 8usize];
    ["Offset of field: cmsghdr::cmsg_len"][::std::mem::offset_of!(cmsghdr, cmsg_len) - 0usize];
    ["Offset of field: cmsghdr::cmsg_level"][::std::mem::offset_of!(cmsghdr, cmsg_level) - 8usize];
    ["Offset of field: cmsghdr::cmsg_type"][::std::mem::offset_of!(cmsghdr, cmsg_type) - 12usize];
    ["Offset of field: cmsghdr::__cmsg_data"]
        [::std::mem::offset_of!(cmsghdr, __cmsg_data) - 16usize];
};
unsafe extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fd_set"][::std::mem::size_of::<__kernel_fd_set>() - 128usize];
    ["Alignment of __kernel_fd_set"][::std::mem::align_of::<__kernel_fd_set>() - 8usize];
    ["Offset of field: __kernel_fd_set::fds_bits"]
        [::std::mem::offset_of!(__kernel_fd_set, fds_bits) - 0usize];
};
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __kernel_fsid_t"][::std::mem::size_of::<__kernel_fsid_t>() - 8usize];
    ["Alignment of __kernel_fsid_t"][::std::mem::align_of::<__kernel_fsid_t>() - 4usize];
    ["Offset of field: __kernel_fsid_t::val"]
        [::std::mem::offset_of!(__kernel_fsid_t, val) - 0usize];
};
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of linger"][::std::mem::size_of::<linger>() - 8usize];
    ["Alignment of linger"][::std::mem::align_of::<linger>() - 4usize];
    ["Offset of field: linger::l_onoff"][::std::mem::offset_of!(linger, l_onoff) - 0usize];
    ["Offset of field: linger::l_linger"][::std::mem::offset_of!(linger, l_linger) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of osockaddr"][::std::mem::size_of::<osockaddr>() - 16usize];
    ["Alignment of osockaddr"][::std::mem::align_of::<osockaddr>() - 2usize];
    ["Offset of field: osockaddr::sa_family"]
        [::std::mem::offset_of!(osockaddr, sa_family) - 0usize];
    ["Offset of field: osockaddr::sa_data"][::std::mem::offset_of!(osockaddr, sa_data) - 2usize];
};
pub const SHUT_RD: _bindgen_ty_3 = 0;
pub const SHUT_WR: _bindgen_ty_3 = 1;
pub const SHUT_RDWR: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *const sockaddr,
        __addr_len: socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
unsafe extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in_addr"][::std::mem::size_of::<in_addr>() - 4usize];
    ["Alignment of in_addr"][::std::mem::align_of::<in_addr>() - 4usize];
    ["Offset of field: in_addr::s_addr"][::std::mem::offset_of!(in_addr, s_addr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_opts"][::std::mem::size_of::<ip_opts>() - 44usize];
    ["Alignment of ip_opts"][::std::mem::align_of::<ip_opts>() - 4usize];
    ["Offset of field: ip_opts::ip_dst"][::std::mem::offset_of!(ip_opts, ip_dst) - 0usize];
    ["Offset of field: ip_opts::ip_opts"][::std::mem::offset_of!(ip_opts, ip_opts) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in_pktinfo"][::std::mem::size_of::<in_pktinfo>() - 12usize];
    ["Alignment of in_pktinfo"][::std::mem::align_of::<in_pktinfo>() - 4usize];
    ["Offset of field: in_pktinfo::ipi_ifindex"]
        [::std::mem::offset_of!(in_pktinfo, ipi_ifindex) - 0usize];
    ["Offset of field: in_pktinfo::ipi_spec_dst"]
        [::std::mem::offset_of!(in_pktinfo, ipi_spec_dst) - 4usize];
    ["Offset of field: in_pktinfo::ipi_addr"]
        [::std::mem::offset_of!(in_pktinfo, ipi_addr) - 8usize];
};
pub const IPPROTO_IP: _bindgen_ty_4 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_4 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_4 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_4 = 4;
pub const IPPROTO_TCP: _bindgen_ty_4 = 6;
pub const IPPROTO_EGP: _bindgen_ty_4 = 8;
pub const IPPROTO_PUP: _bindgen_ty_4 = 12;
pub const IPPROTO_UDP: _bindgen_ty_4 = 17;
pub const IPPROTO_IDP: _bindgen_ty_4 = 22;
pub const IPPROTO_TP: _bindgen_ty_4 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_4 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_4 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_4 = 46;
pub const IPPROTO_GRE: _bindgen_ty_4 = 47;
pub const IPPROTO_ESP: _bindgen_ty_4 = 50;
pub const IPPROTO_AH: _bindgen_ty_4 = 51;
pub const IPPROTO_MTP: _bindgen_ty_4 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_4 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_4 = 98;
pub const IPPROTO_PIM: _bindgen_ty_4 = 103;
pub const IPPROTO_COMP: _bindgen_ty_4 = 108;
pub const IPPROTO_L2TP: _bindgen_ty_4 = 115;
pub const IPPROTO_SCTP: _bindgen_ty_4 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_4 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_4 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_4 = 143;
pub const IPPROTO_RAW: _bindgen_ty_4 = 255;
pub const IPPROTO_SMC: _bindgen_ty_4 = 256;
pub const IPPROTO_MPTCP: _bindgen_ty_4 = 262;
pub const IPPROTO_MAX: _bindgen_ty_4 = 263;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_5 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_5 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_5 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_5 = 58;
pub const IPPROTO_NONE: _bindgen_ty_5 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_5 = 60;
pub const IPPROTO_MH: _bindgen_ty_5 = 135;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_6 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_6 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_6 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_6 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_6 = 15;
pub const IPPORT_FTP: _bindgen_ty_6 = 21;
pub const IPPORT_TELNET: _bindgen_ty_6 = 23;
pub const IPPORT_SMTP: _bindgen_ty_6 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_6 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_6 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_6 = 43;
pub const IPPORT_MTP: _bindgen_ty_6 = 57;
pub const IPPORT_TFTP: _bindgen_ty_6 = 69;
pub const IPPORT_RJE: _bindgen_ty_6 = 77;
pub const IPPORT_FINGER: _bindgen_ty_6 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_6 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_6 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_6 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_6 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_6 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_6 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_6 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_6 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_6 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_6 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_6 = 5000;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in6_addr__bindgen_ty_1"][::std::mem::size_of::<in6_addr__bindgen_ty_1>() - 16usize];
    ["Alignment of in6_addr__bindgen_ty_1"]
        [::std::mem::align_of::<in6_addr__bindgen_ty_1>() - 4usize];
    ["Offset of field: in6_addr__bindgen_ty_1::__u6_addr8"]
        [::std::mem::offset_of!(in6_addr__bindgen_ty_1, __u6_addr8) - 0usize];
    ["Offset of field: in6_addr__bindgen_ty_1::__u6_addr16"]
        [::std::mem::offset_of!(in6_addr__bindgen_ty_1, __u6_addr16) - 0usize];
    ["Offset of field: in6_addr__bindgen_ty_1::__u6_addr32"]
        [::std::mem::offset_of!(in6_addr__bindgen_ty_1, __u6_addr32) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of in6_addr"][::std::mem::size_of::<in6_addr>() - 16usize];
    ["Alignment of in6_addr"][::std::mem::align_of::<in6_addr>() - 4usize];
    ["Offset of field: in6_addr::__in6_u"][::std::mem::offset_of!(in6_addr, __in6_u) - 0usize];
};
unsafe extern "C" {
    pub static in6addr_any: in6_addr;
}
unsafe extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_in"][::std::mem::size_of::<sockaddr_in>() - 16usize];
    ["Alignment of sockaddr_in"][::std::mem::align_of::<sockaddr_in>() - 4usize];
    ["Offset of field: sockaddr_in::sin_family"]
        [::std::mem::offset_of!(sockaddr_in, sin_family) - 0usize];
    ["Offset of field: sockaddr_in::sin_port"]
        [::std::mem::offset_of!(sockaddr_in, sin_port) - 2usize];
    ["Offset of field: sockaddr_in::sin_addr"]
        [::std::mem::offset_of!(sockaddr_in, sin_addr) - 4usize];
    ["Offset of field: sockaddr_in::sin_zero"]
        [::std::mem::offset_of!(sockaddr_in, sin_zero) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sockaddr_in6"][::std::mem::size_of::<sockaddr_in6>() - 28usize];
    ["Alignment of sockaddr_in6"][::std::mem::align_of::<sockaddr_in6>() - 4usize];
    ["Offset of field: sockaddr_in6::sin6_family"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_family) - 0usize];
    ["Offset of field: sockaddr_in6::sin6_port"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_port) - 2usize];
    ["Offset of field: sockaddr_in6::sin6_flowinfo"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_flowinfo) - 4usize];
    ["Offset of field: sockaddr_in6::sin6_addr"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_addr) - 8usize];
    ["Offset of field: sockaddr_in6::sin6_scope_id"]
        [::std::mem::offset_of!(sockaddr_in6, sin6_scope_id) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_mreq"][::std::mem::size_of::<ip_mreq>() - 8usize];
    ["Alignment of ip_mreq"][::std::mem::align_of::<ip_mreq>() - 4usize];
    ["Offset of field: ip_mreq::imr_multiaddr"]
        [::std::mem::offset_of!(ip_mreq, imr_multiaddr) - 0usize];
    ["Offset of field: ip_mreq::imr_interface"]
        [::std::mem::offset_of!(ip_mreq, imr_interface) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_mreqn"][::std::mem::size_of::<ip_mreqn>() - 12usize];
    ["Alignment of ip_mreqn"][::std::mem::align_of::<ip_mreqn>() - 4usize];
    ["Offset of field: ip_mreqn::imr_multiaddr"]
        [::std::mem::offset_of!(ip_mreqn, imr_multiaddr) - 0usize];
    ["Offset of field: ip_mreqn::imr_address"]
        [::std::mem::offset_of!(ip_mreqn, imr_address) - 4usize];
    ["Offset of field: ip_mreqn::imr_ifindex"]
        [::std::mem::offset_of!(ip_mreqn, imr_ifindex) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_mreq_source"][::std::mem::size_of::<ip_mreq_source>() - 12usize];
    ["Alignment of ip_mreq_source"][::std::mem::align_of::<ip_mreq_source>() - 4usize];
    ["Offset of field: ip_mreq_source::imr_multiaddr"]
        [::std::mem::offset_of!(ip_mreq_source, imr_multiaddr) - 0usize];
    ["Offset of field: ip_mreq_source::imr_interface"]
        [::std::mem::offset_of!(ip_mreq_source, imr_interface) - 4usize];
    ["Offset of field: ip_mreq_source::imr_sourceaddr"]
        [::std::mem::offset_of!(ip_mreq_source, imr_sourceaddr) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ipv6_mreq"][::std::mem::size_of::<ipv6_mreq>() - 20usize];
    ["Alignment of ipv6_mreq"][::std::mem::align_of::<ipv6_mreq>() - 4usize];
    ["Offset of field: ipv6_mreq::ipv6mr_multiaddr"]
        [::std::mem::offset_of!(ipv6_mreq, ipv6mr_multiaddr) - 0usize];
    ["Offset of field: ipv6_mreq::ipv6mr_interface"]
        [::std::mem::offset_of!(ipv6_mreq, ipv6mr_interface) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of group_req"][::std::mem::size_of::<group_req>() - 136usize];
    ["Alignment of group_req"][::std::mem::align_of::<group_req>() - 8usize];
    ["Offset of field: group_req::gr_interface"]
        [::std::mem::offset_of!(group_req, gr_interface) - 0usize];
    ["Offset of field: group_req::gr_group"][::std::mem::offset_of!(group_req, gr_group) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of group_source_req"][::std::mem::size_of::<group_source_req>() - 264usize];
    ["Alignment of group_source_req"][::std::mem::align_of::<group_source_req>() - 8usize];
    ["Offset of field: group_source_req::gsr_interface"]
        [::std::mem::offset_of!(group_source_req, gsr_interface) - 0usize];
    ["Offset of field: group_source_req::gsr_group"]
        [::std::mem::offset_of!(group_source_req, gsr_group) - 8usize];
    ["Offset of field: group_source_req::gsr_source"]
        [::std::mem::offset_of!(group_source_req, gsr_source) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ip_msfilter"][::std::mem::size_of::<ip_msfilter>() - 20usize];
    ["Alignment of ip_msfilter"][::std::mem::align_of::<ip_msfilter>() - 4usize];
    ["Offset of field: ip_msfilter::imsf_multiaddr"]
        [::std::mem::offset_of!(ip_msfilter, imsf_multiaddr) - 0usize];
    ["Offset of field: ip_msfilter::imsf_interface"]
        [::std::mem::offset_of!(ip_msfilter, imsf_interface) - 4usize];
    ["Offset of field: ip_msfilter::imsf_fmode"]
        [::std::mem::offset_of!(ip_msfilter, imsf_fmode) - 8usize];
    ["Offset of field: ip_msfilter::imsf_numsrc"]
        [::std::mem::offset_of!(ip_msfilter, imsf_numsrc) - 12usize];
    ["Offset of field: ip_msfilter::imsf_slist"]
        [::std::mem::offset_of!(ip_msfilter, imsf_slist) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of group_filter"][::std::mem::size_of::<group_filter>() - 272usize];
    ["Alignment of group_filter"][::std::mem::align_of::<group_filter>() - 8usize];
    ["Offset of field: group_filter::gf_interface"]
        [::std::mem::offset_of!(group_filter, gf_interface) - 0usize];
    ["Offset of field: group_filter::gf_group"]
        [::std::mem::offset_of!(group_filter, gf_group) - 8usize];
    ["Offset of field: group_filter::gf_fmode"]
        [::std::mem::offset_of!(group_filter, gf_fmode) - 136usize];
    ["Offset of field: group_filter::gf_numsrc"]
        [::std::mem::offset_of!(group_filter, gf_numsrc) - 140usize];
    ["Offset of field: group_filter::gf_slist"]
        [::std::mem::offset_of!(group_filter, gf_slist) - 144usize];
};
unsafe extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
unsafe extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
unsafe extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
unsafe extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
unsafe extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type useconds_t = __useconds_t;

pub const _PC_LINK_MAX: _bindgen_ty_7 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_7 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_7 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_7 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_7 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_7 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_7 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_7 = 7;
pub const _PC_VDISABLE: _bindgen_ty_7 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_7 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_7 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_7 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_7 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_7 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_7 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_7 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_7 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_7 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_7 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_7 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_7 = 20;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_8 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_8 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_8 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_8 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_8 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_8 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_8 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_8 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_8 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_8 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_8 = 10;
pub const _SC_TIMERS: _bindgen_ty_8 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_8 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_8 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_8 = 14;
pub const _SC_FSYNC: _bindgen_ty_8 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_8 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_8 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_8 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_8 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_8 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_8 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_8 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_8 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_8 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_8 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_8 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_8 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_8 = 28;
pub const _SC_VERSION: _bindgen_ty_8 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_8 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_8 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_8 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_8 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_8 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_8 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_8 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_8 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_8 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_8 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_8 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_8 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_8 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_8 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_8 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_8 = 45;
pub const _SC_2_VERSION: _bindgen_ty_8 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_8 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_8 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_8 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_8 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_8 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_8 = 52;
pub const _SC_PII: _bindgen_ty_8 = 53;
pub const _SC_PII_XTI: _bindgen_ty_8 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_8 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_8 = 56;
pub const _SC_PII_OSI: _bindgen_ty_8 = 57;
pub const _SC_POLL: _bindgen_ty_8 = 58;
pub const _SC_SELECT: _bindgen_ty_8 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_8 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_8 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_8 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_8 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_8 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_8 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_8 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_8 = 66;
pub const _SC_THREADS: _bindgen_ty_8 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_8 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_8 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_8 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_8 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_8 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_8 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_8 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_8 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_8 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_8 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_8 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_8 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_8 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_8 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_8 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_8 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_8 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_8 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_8 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_8 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_8 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_8 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_8 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_8 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_8 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_8 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_8 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_8 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_8 = 96;
pub const _SC_2_UPE: _bindgen_ty_8 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_8 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_8 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_8 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_8 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_8 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_8 = 103;
pub const _SC_INT_MAX: _bindgen_ty_8 = 104;
pub const _SC_INT_MIN: _bindgen_ty_8 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_8 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_8 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_8 = 108;
pub const _SC_NZERO: _bindgen_ty_8 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_8 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_8 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_8 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_8 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_8 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_8 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_8 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_8 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_8 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_8 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_8 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_8 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_8 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_8 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_8 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_8 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_8 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_8 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_8 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_8 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_8 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_8 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_8 = 132;
pub const _SC_BARRIERS: _bindgen_ty_8 = 133;
pub const _SC_BASE: _bindgen_ty_8 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_8 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_8 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_8 = 137;
pub const _SC_CPUTIME: _bindgen_ty_8 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_8 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_8 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_8 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_8 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_8 = 143;
pub const _SC_FIFO: _bindgen_ty_8 = 144;
pub const _SC_PIPE: _bindgen_ty_8 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_8 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_8 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_8 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_8 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_8 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_8 = 151;
pub const _SC_NETWORKING: _bindgen_ty_8 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_8 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_8 = 154;
pub const _SC_REGEXP: _bindgen_ty_8 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_8 = 156;
pub const _SC_SHELL: _bindgen_ty_8 = 157;
pub const _SC_SIGNALS: _bindgen_ty_8 = 158;
pub const _SC_SPAWN: _bindgen_ty_8 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_8 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_8 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_8 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_8 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_8 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_8 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_8 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_8 = 167;
pub const _SC_2_PBS: _bindgen_ty_8 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_8 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_8 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_8 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_8 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_8 = 173;
pub const _SC_STREAMS: _bindgen_ty_8 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_8 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_8 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_8 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_8 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_8 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_8 = 180;
pub const _SC_TRACE: _bindgen_ty_8 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_8 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_8 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_8 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_8 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_8 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_8 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_8 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_8 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_8 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_8 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_8 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_8 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_8 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_8 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_8 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_8 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_8 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_8 = 199;
pub const _SC_IPV6: _bindgen_ty_8 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_8 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_8 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_8 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_8 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_8 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_8 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_8 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_8 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_8 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_8 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_8 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_8 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_8 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_8 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_8 = 250;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_9 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_9 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_9 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_9 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_9 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_9 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_9 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_9 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_9 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_9 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_9 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_9 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_9 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_9 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_9 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_9 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_9 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_9 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_9 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_9 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_9 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_9 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_9 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_9 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_9 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_9 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_9 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_9 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_9 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_9 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_9 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_9 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_9 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_9 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_9 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_9 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_9 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_9 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_9 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_9 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_9 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_9 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_9 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_9 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_9 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_9 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_9 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_9 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_9 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_9 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_9 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_9 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_9 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_9 = 1149;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;

pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " @struct obj_watch_t\n One item from list_watchers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obj_watch_t {
    #[doc = " Address of the Watcher"]
    pub addr: [::std::os::raw::c_char; 256usize],
    #[doc = " Watcher ID"]
    pub watcher_id: i64,
    #[doc = " Cookie"]
    pub cookie: u64,
    #[doc = " Timeout in Seconds"]
    pub timeout_seconds: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of obj_watch_t"][::std::mem::size_of::<obj_watch_t>() - 280usize];
    ["Alignment of obj_watch_t"][::std::mem::align_of::<obj_watch_t>() - 8usize];
    ["Offset of field: obj_watch_t::addr"][::std::mem::offset_of!(obj_watch_t, addr) - 0usize];
    ["Offset of field: obj_watch_t::watcher_id"]
        [::std::mem::offset_of!(obj_watch_t, watcher_id) - 256usize];
    ["Offset of field: obj_watch_t::cookie"]
        [::std::mem::offset_of!(obj_watch_t, cookie) - 264usize];
    ["Offset of field: obj_watch_t::timeout_seconds"]
        [::std::mem::offset_of!(obj_watch_t, timeout_seconds) - 272usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notify_ack_t {
    pub notifier_id: u64,
    pub cookie: u64,
    pub payload: *mut ::std::os::raw::c_char,
    pub payload_len: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of notify_ack_t"][::std::mem::size_of::<notify_ack_t>() - 32usize];
    ["Alignment of notify_ack_t"][::std::mem::align_of::<notify_ack_t>() - 8usize];
    ["Offset of field: notify_ack_t::notifier_id"]
        [::std::mem::offset_of!(notify_ack_t, notifier_id) - 0usize];
    ["Offset of field: notify_ack_t::cookie"]
        [::std::mem::offset_of!(notify_ack_t, cookie) - 8usize];
    ["Offset of field: notify_ack_t::payload"]
        [::std::mem::offset_of!(notify_ack_t, payload) - 16usize];
    ["Offset of field: notify_ack_t::payload_len"]
        [::std::mem::offset_of!(notify_ack_t, payload_len) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notify_timeout_t {
    pub notifier_id: u64,
    pub cookie: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of notify_timeout_t"][::std::mem::size_of::<notify_timeout_t>() - 16usize];
    ["Alignment of notify_timeout_t"][::std::mem::align_of::<notify_timeout_t>() - 8usize];
    ["Offset of field: notify_timeout_t::notifier_id"]
        [::std::mem::offset_of!(notify_timeout_t, notifier_id) - 0usize];
    ["Offset of field: notify_timeout_t::cookie"]
        [::std::mem::offset_of!(notify_timeout_t, cookie) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timezone"][::std::mem::size_of::<timezone>() - 8usize];
    ["Alignment of timezone"][::std::mem::align_of::<timezone>() - 4usize];
    ["Offset of field: timezone::tz_minuteswest"]
        [::std::mem::offset_of!(timezone, tz_minuteswest) - 0usize];
    ["Offset of field: timezone::tz_dsttime"]
        [::std::mem::offset_of!(timezone, tz_dsttime) - 4usize];
};
unsafe extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerval"][::std::mem::size_of::<itimerval>() - 32usize];
    ["Alignment of itimerval"][::std::mem::align_of::<itimerval>() - 8usize];
    ["Offset of field: itimerval::it_interval"]
        [::std::mem::offset_of!(itimerval, it_interval) - 0usize];
    ["Offset of field: itimerval::it_value"][::std::mem::offset_of!(itimerval, it_value) - 16usize];
};
pub type __itimer_which_t = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub const LIBRADOS_OP_FLAG_EXCL: _bindgen_ty_10 = 1;
pub const LIBRADOS_OP_FLAG_FAILOK: _bindgen_ty_10 = 2;
pub const LIBRADOS_OP_FLAG_FADVISE_RANDOM: _bindgen_ty_10 = 4;
pub const LIBRADOS_OP_FLAG_FADVISE_SEQUENTIAL: _bindgen_ty_10 = 8;
pub const LIBRADOS_OP_FLAG_FADVISE_WILLNEED: _bindgen_ty_10 = 16;
pub const LIBRADOS_OP_FLAG_FADVISE_DONTNEED: _bindgen_ty_10 = 32;
pub const LIBRADOS_OP_FLAG_FADVISE_NOCACHE: _bindgen_ty_10 = 64;
pub const LIBRADOS_OP_FLAG_FADVISE_FUA: _bindgen_ty_10 = 128;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const LIBRADOS_CMPXATTR_OP_EQ: _bindgen_ty_11 = 1;
pub const LIBRADOS_CMPXATTR_OP_NE: _bindgen_ty_11 = 2;
pub const LIBRADOS_CMPXATTR_OP_GT: _bindgen_ty_11 = 3;
pub const LIBRADOS_CMPXATTR_OP_GTE: _bindgen_ty_11 = 4;
pub const LIBRADOS_CMPXATTR_OP_LT: _bindgen_ty_11 = 5;
pub const LIBRADOS_CMPXATTR_OP_LTE: _bindgen_ty_11 = 6;
#[doc = " @name xattr comparison operations\n Operators for comparing xattrs on objects, and aborting the\n rados_read_op or rados_write_op transaction if the comparison\n fails.\n\n @{"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const LIBRADOS_OPERATION_NOFLAG: _bindgen_ty_12 = 0;
pub const LIBRADOS_OPERATION_BALANCE_READS: _bindgen_ty_12 = 1;
pub const LIBRADOS_OPERATION_LOCALIZE_READS: _bindgen_ty_12 = 2;
pub const LIBRADOS_OPERATION_ORDER_READS_WRITES: _bindgen_ty_12 = 4;
pub const LIBRADOS_OPERATION_IGNORE_CACHE: _bindgen_ty_12 = 8;
pub const LIBRADOS_OPERATION_SKIPRWLOCKS: _bindgen_ty_12 = 16;
pub const LIBRADOS_OPERATION_IGNORE_OVERLAY: _bindgen_ty_12 = 32;
pub const LIBRADOS_OPERATION_FULL_TRY: _bindgen_ty_12 = 64;
pub const LIBRADOS_OPERATION_FULL_FORCE: _bindgen_ty_12 = 128;
pub const LIBRADOS_OPERATION_IGNORE_REDIRECT: _bindgen_ty_12 = 256;
pub const LIBRADOS_OPERATION_ORDERSNAP: _bindgen_ty_12 = 512;
pub const LIBRADOS_OPERATION_RETURNVEC: _bindgen_ty_12 = 1024;
#[doc = " @name Operation Flags\n Flags for rados_read_op_operate(), rados_write_op_operate(),\n rados_aio_read_op_operate(), and rados_aio_write_op_operate().\n See librados.hpp for details.\n @{"]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const LIBRADOS_ALLOC_HINT_FLAG_SEQUENTIAL_WRITE: _bindgen_ty_13 = 1;
pub const LIBRADOS_ALLOC_HINT_FLAG_RANDOM_WRITE: _bindgen_ty_13 = 2;
pub const LIBRADOS_ALLOC_HINT_FLAG_SEQUENTIAL_READ: _bindgen_ty_13 = 4;
pub const LIBRADOS_ALLOC_HINT_FLAG_RANDOM_READ: _bindgen_ty_13 = 8;
pub const LIBRADOS_ALLOC_HINT_FLAG_APPEND_ONLY: _bindgen_ty_13 = 16;
pub const LIBRADOS_ALLOC_HINT_FLAG_IMMUTABLE: _bindgen_ty_13 = 32;
pub const LIBRADOS_ALLOC_HINT_FLAG_SHORTLIVED: _bindgen_ty_13 = 64;
pub const LIBRADOS_ALLOC_HINT_FLAG_LONGLIVED: _bindgen_ty_13 = 128;
pub const LIBRADOS_ALLOC_HINT_FLAG_COMPRESSIBLE: _bindgen_ty_13 = 256;
pub const LIBRADOS_ALLOC_HINT_FLAG_INCOMPRESSIBLE: _bindgen_ty_13 = 512;
#[doc = " @name Alloc hint flags\n Flags for rados_write_op_alloc_hint2() and rados_set_alloc_hint2()\n indicating future IO patterns.\n @{"]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const rados_checksum_type_t_LIBRADOS_CHECKSUM_TYPE_XXHASH32: rados_checksum_type_t = 0;
pub const rados_checksum_type_t_LIBRADOS_CHECKSUM_TYPE_XXHASH64: rados_checksum_type_t = 1;
pub const rados_checksum_type_t_LIBRADOS_CHECKSUM_TYPE_CRC32C: rados_checksum_type_t = 2;
#[doc = " @}"]
pub type rados_checksum_type_t = ::std::os::raw::c_uint;
pub type rados_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_config_t\n\n A handle for the ceph configuration context for the rados_t cluster\n instance.  This can be used to share configuration context/state\n (e.g., logging configuration) between librados instance.\n\n @warning The config context does not have independent reference\n counting.  As such, a rados_config_t handle retrieved from a given\n rados_t is only valid as long as that rados_t."]
pub type rados_config_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_ioctx_t\n\n An io context encapsulates a few settings for all I/O operations\n done on it:\n - pool - set when the io context is created (see rados_ioctx_create())\n - snapshot context for writes (see\n   rados_ioctx_selfmanaged_snap_set_write_ctx())\n - snapshot id to read from (see rados_ioctx_snap_set_read())\n - object locator for all single-object operations (see\n   rados_ioctx_locator_set_key())\n - namespace for all single-object operations (see\n   rados_ioctx_set_namespace()).  Set to LIBRADOS_ALL_NSPACES\n   before rados_nobjects_list_open() will list all objects in all\n   namespaces.\n\n @warning Changing any of these settings is not thread-safe -\n librados users must synchronize any of these changes on their own,\n or use separate io contexts for each thread"]
pub type rados_ioctx_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_list_ctx_t\n\n An iterator for listing the objects in a pool.\n Used with rados_nobjects_list_open(),\n rados_nobjects_list_next(), rados_nobjects_list_next2(), and\n rados_nobjects_list_close()."]
pub type rados_list_ctx_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_object_list_cursor\n\n The cursor used with rados_enumerate_objects\n and accompanying methods."]
pub type rados_object_list_cursor = *mut ::std::os::raw::c_void;
#[doc = " @struct rados_object_list_item\n\n The item populated by rados_object_list in\n the results array."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rados_object_list_item {
    #[doc = " oid length"]
    pub oid_length: usize,
    #[doc = " name of the object"]
    pub oid: *mut ::std::os::raw::c_char,
    #[doc = " namespace length"]
    pub nspace_length: usize,
    #[doc = " the object namespace"]
    pub nspace: *mut ::std::os::raw::c_char,
    #[doc = " locator length"]
    pub locator_length: usize,
    #[doc = " object locator"]
    pub locator: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rados_object_list_item"][::std::mem::size_of::<rados_object_list_item>() - 48usize];
    ["Alignment of rados_object_list_item"]
        [::std::mem::align_of::<rados_object_list_item>() - 8usize];
    ["Offset of field: rados_object_list_item::oid_length"]
        [::std::mem::offset_of!(rados_object_list_item, oid_length) - 0usize];
    ["Offset of field: rados_object_list_item::oid"]
        [::std::mem::offset_of!(rados_object_list_item, oid) - 8usize];
    ["Offset of field: rados_object_list_item::nspace_length"]
        [::std::mem::offset_of!(rados_object_list_item, nspace_length) - 16usize];
    ["Offset of field: rados_object_list_item::nspace"]
        [::std::mem::offset_of!(rados_object_list_item, nspace) - 24usize];
    ["Offset of field: rados_object_list_item::locator_length"]
        [::std::mem::offset_of!(rados_object_list_item, locator_length) - 32usize];
    ["Offset of field: rados_object_list_item::locator"]
        [::std::mem::offset_of!(rados_object_list_item, locator) - 40usize];
};
#[doc = " @typedef rados_snap_t\n The id of a snapshot."]
pub type rados_snap_t = u64;
#[doc = " @typedef rados_xattrs_iter_t\n An iterator for listing extended attrbutes on an object.\n Used with rados_getxattrs(), rados_getxattrs_next(), and\n rados_getxattrs_end()."]
pub type rados_xattrs_iter_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_omap_iter_t\n An iterator for listing omap key/value pairs on an object.\n Used with rados_read_op_omap_get_keys(), rados_read_op_omap_get_vals(),\n rados_read_op_omap_get_vals_by_keys(), rados_omap_get_next(), and\n rados_omap_get_end()."]
pub type rados_omap_iter_t = *mut ::std::os::raw::c_void;
#[doc = " @struct rados_pool_stat_t\n Usage information for a pool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rados_pool_stat_t {
    #[doc = " space used in bytes"]
    pub num_bytes: u64,
    #[doc = " space used in KB"]
    pub num_kb: u64,
    #[doc = " number of objects in the pool"]
    pub num_objects: u64,
    #[doc = " number of clones of objects"]
    pub num_object_clones: u64,
    #[doc = " num_objects * num_replicas"]
    pub num_object_copies: u64,
    #[doc = " number of objects missing on primary"]
    pub num_objects_missing_on_primary: u64,
    #[doc = " number of objects found on no OSDs"]
    pub num_objects_unfound: u64,
    #[doc = " number of objects replicated fewer times than they should be\n (but found on at least one OSD)"]
    pub num_objects_degraded: u64,
    #[doc = " number of objects read"]
    pub num_rd: u64,
    #[doc = " objects read in KB"]
    pub num_rd_kb: u64,
    #[doc = " number of objects written"]
    pub num_wr: u64,
    #[doc = " objects written in KB"]
    pub num_wr_kb: u64,
    #[doc = " bytes originally provided by user"]
    pub num_user_bytes: u64,
    #[doc = " bytes passed compression"]
    pub compressed_bytes_orig: u64,
    #[doc = " bytes resulted after compression"]
    pub compressed_bytes: u64,
    #[doc = " bytes allocated at storage"]
    pub compressed_bytes_alloc: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rados_pool_stat_t"][::std::mem::size_of::<rados_pool_stat_t>() - 128usize];
    ["Alignment of rados_pool_stat_t"][::std::mem::align_of::<rados_pool_stat_t>() - 8usize];
    ["Offset of field: rados_pool_stat_t::num_bytes"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_bytes) - 0usize];
    ["Offset of field: rados_pool_stat_t::num_kb"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_kb) - 8usize];
    ["Offset of field: rados_pool_stat_t::num_objects"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_objects) - 16usize];
    ["Offset of field: rados_pool_stat_t::num_object_clones"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_object_clones) - 24usize];
    ["Offset of field: rados_pool_stat_t::num_object_copies"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_object_copies) - 32usize];
    ["Offset of field: rados_pool_stat_t::num_objects_missing_on_primary"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_objects_missing_on_primary) - 40usize];
    ["Offset of field: rados_pool_stat_t::num_objects_unfound"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_objects_unfound) - 48usize];
    ["Offset of field: rados_pool_stat_t::num_objects_degraded"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_objects_degraded) - 56usize];
    ["Offset of field: rados_pool_stat_t::num_rd"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_rd) - 64usize];
    ["Offset of field: rados_pool_stat_t::num_rd_kb"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_rd_kb) - 72usize];
    ["Offset of field: rados_pool_stat_t::num_wr"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_wr) - 80usize];
    ["Offset of field: rados_pool_stat_t::num_wr_kb"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_wr_kb) - 88usize];
    ["Offset of field: rados_pool_stat_t::num_user_bytes"]
        [::std::mem::offset_of!(rados_pool_stat_t, num_user_bytes) - 96usize];
    ["Offset of field: rados_pool_stat_t::compressed_bytes_orig"]
        [::std::mem::offset_of!(rados_pool_stat_t, compressed_bytes_orig) - 104usize];
    ["Offset of field: rados_pool_stat_t::compressed_bytes"]
        [::std::mem::offset_of!(rados_pool_stat_t, compressed_bytes) - 112usize];
    ["Offset of field: rados_pool_stat_t::compressed_bytes_alloc"]
        [::std::mem::offset_of!(rados_pool_stat_t, compressed_bytes_alloc) - 120usize];
};
#[doc = " @struct rados_cluster_stat_t\n Cluster-wide usage information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rados_cluster_stat_t {
    #[doc = " total device size"]
    pub kb: u64,
    #[doc = " total used"]
    pub kb_used: u64,
    #[doc = " total available/free"]
    pub kb_avail: u64,
    #[doc = " number of objects"]
    pub num_objects: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rados_cluster_stat_t"][::std::mem::size_of::<rados_cluster_stat_t>() - 32usize];
    ["Alignment of rados_cluster_stat_t"][::std::mem::align_of::<rados_cluster_stat_t>() - 8usize];
    ["Offset of field: rados_cluster_stat_t::kb"]
        [::std::mem::offset_of!(rados_cluster_stat_t, kb) - 0usize];
    ["Offset of field: rados_cluster_stat_t::kb_used"]
        [::std::mem::offset_of!(rados_cluster_stat_t, kb_used) - 8usize];
    ["Offset of field: rados_cluster_stat_t::kb_avail"]
        [::std::mem::offset_of!(rados_cluster_stat_t, kb_avail) - 16usize];
    ["Offset of field: rados_cluster_stat_t::num_objects"]
        [::std::mem::offset_of!(rados_cluster_stat_t, num_objects) - 24usize];
};
#[doc = " @typedef rados_write_op_t\n\n An object write operation stores a number of operations which can be\n executed atomically. For usage, see:\n - Creation and deletion: rados_create_write_op() rados_release_write_op()\n - Extended attribute manipulation: rados_write_op_cmpxattr()\n   rados_write_op_cmpxattr(), rados_write_op_setxattr(),\n   rados_write_op_rmxattr()\n - Object map key/value pairs: rados_write_op_omap_set(),\n   rados_write_op_omap_rm_keys(), rados_write_op_omap_clear(),\n   rados_write_op_omap_cmp()\n - Object properties: rados_write_op_assert_exists(),\n   rados_write_op_assert_version()\n - Creating objects: rados_write_op_create()\n - IO on objects: rados_write_op_append(), rados_write_op_write(), rados_write_op_zero\n   rados_write_op_write_full(), rados_write_op_writesame(), rados_write_op_remove,\n   rados_write_op_truncate(), rados_write_op_zero(), rados_write_op_cmpext()\n - Hints: rados_write_op_set_alloc_hint()\n - Performing the operation: rados_write_op_operate(), rados_aio_write_op_operate()"]
pub type rados_write_op_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_read_op_t\n\n An object read operation stores a number of operations which can be\n executed atomically. For usage, see:\n - Creation and deletion: rados_create_read_op() rados_release_read_op()\n - Extended attribute manipulation: rados_read_op_cmpxattr(),\n   rados_read_op_getxattr(), rados_read_op_getxattrs()\n - Object map key/value pairs: rados_read_op_omap_get_vals(),\n   rados_read_op_omap_get_keys(), rados_read_op_omap_get_vals_by_keys(),\n   rados_read_op_omap_cmp()\n - Object properties: rados_read_op_stat(), rados_read_op_assert_exists(),\n   rados_read_op_assert_version()\n - IO on objects: rados_read_op_read(), rados_read_op_checksum(),\n   rados_read_op_cmpext()\n - Custom operations: rados_read_op_exec(), rados_read_op_exec_user_buf()\n - Request properties: rados_read_op_set_flags()\n - Performing the operation: rados_read_op_operate(),\n   rados_aio_read_op_operate()"]
pub type rados_read_op_t = *mut ::std::os::raw::c_void;
#[doc = " @typedef rados_completion_t\n Represents the state of an asynchronous operation - it contains the\n return value once the operation completes, and can be used to block\n until the operation is complete or safe."]
pub type rados_completion_t = *mut ::std::os::raw::c_void;
#[doc = " @struct blkin_trace_info\n blkin trace information for Zipkin tracing"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blkin_trace_info {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the version of librados.\n\n The version number is major.minor.extra. Note that this is\n unrelated to the Ceph version number.\n\n TODO: define version semantics, i.e.:\n - incrementing major is for backwards-incompatible changes\n - incrementing minor is for backwards-compatible changes\n - incrementing extra is for bug fixes\n\n @param major where to store the major version number\n @param minor where to store the minor version number\n @param extra where to store the extra version number"]
    pub fn rados_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        extra: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Create a handle for communicating with a RADOS cluster.\n\n Ceph environment variables are read when this is called, so if\n $CEPH_ARGS specifies everything you need to connect, no further\n configuration is necessary.\n\n @param cluster where to store the handle\n @param id the user to connect as (i.e. admin, not client.admin)\n @returns 0 on success, negative error code on failure"]
    pub fn rados_create(
        cluster: *mut rados_t,
        id: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Extended version of rados_create.\n\n Like rados_create, but\n 1) don't assume 'client\\.'+id; allow full specification of name\n 2) allow specification of cluster name\n 3) flags for future expansion"]
    pub fn rados_create2(
        pcluster: *mut rados_t,
        clustername: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        flags: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize a cluster handle from an existing configuration.\n\n Share configuration state with another rados_t instance.\n\n @param cluster where to store the handle\n @param cct the existing configuration to use\n @returns 0 on success, negative error code on failure"]
    pub fn rados_create_with_context(
        cluster: *mut rados_t,
        cct: rados_config_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Ping the monitor with ID mon_id, storing the resulting reply in\n buf (if specified) with a maximum size of len.\n\n The result buffer is allocated on the heap; the caller is\n expected to release that memory with rados_buffer_free().  The\n buffer and length pointers can be NULL, in which case they are\n not filled in.\n\n @param cluster         cluster handle\n @param mon_id [in]     ID of the monitor to ping\n @param outstr [out]    double pointer with the resulting reply\n @param outstrlen [out] pointer with the size of the reply in outstr"]
    pub fn rados_ping_monitor(
        cluster: rados_t,
        mon_id: *const ::std::os::raw::c_char,
        outstr: *mut *mut ::std::os::raw::c_char,
        outstrlen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Connect to the cluster.\n\n @note BUG: Before calling this, calling a function that communicates with the\n cluster will crash.\n\n @pre The cluster handle is configured with at least a monitor\n address. If cephx is enabled, a client name and secret must also be\n set.\n\n @post If this succeeds, any function in librados may be used\n\n @param cluster The cluster to connect to.\n @returns 0 on success, negative error code on failure"]
    pub fn rados_connect(cluster: rados_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disconnects from the cluster.\n\n For clean up, this is only necessary after rados_connect() has\n succeeded.\n\n @warning This does not guarantee any asynchronous writes have\n completed. To do that, you must call rados_aio_flush() on all open\n io contexts.\n\n @warning We implicitly call rados_watch_flush() on shutdown.  If\n there are watches being used, this should be done explicitly before\n destroying the relevant IoCtx.  We do it here as a safety measure.\n\n @post the cluster handle cannot be used again\n\n @param cluster the cluster to shutdown"]
    pub fn rados_shutdown(cluster: rados_t);
}
unsafe extern "C" {
    #[doc = " Configure the cluster handle using a Ceph config file\n\n If path is NULL, the default locations are searched, and the first\n found is used. The locations are:\n - $CEPH_CONF (environment variable)\n - /etc/ceph/ceph.conf\n - ~/.ceph/config\n - ceph.conf (in the current working directory)\n\n @pre rados_connect() has not been called on the cluster handle\n\n @param cluster cluster handle to configure\n @param path path to a Ceph configuration file\n @returns 0 on success, negative error code on failure"]
    pub fn rados_conf_read_file(
        cluster: rados_t,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the cluster handle with command line arguments\n\n argv can contain any common Ceph command line option, including any\n configuration parameter prefixed by '--' and replacing spaces with\n dashes or underscores. For example, the following options are equivalent:\n - --mon-host 10.0.0.1:6789\n - --mon_host 10.0.0.1:6789\n - -m 10.0.0.1:6789\n\n @pre rados_connect() has not been called on the cluster handle\n\n @param cluster cluster handle to configure\n @param argc number of arguments in argv\n @param argv arguments to parse\n @returns 0 on success, negative error code on failure"]
    pub fn rados_conf_parse_argv(
        cluster: rados_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the cluster handle with command line arguments, returning\n any remainders.  Same rados_conf_parse_argv, except for extra\n remargv argument to hold returns unrecognized arguments.\n\n @pre rados_connect() has not been called on the cluster handle\n\n @param cluster cluster handle to configure\n @param argc number of arguments in argv\n @param argv arguments to parse\n @param remargv char* array for returned unrecognized arguments\n @returns 0 on success, negative error code on failure"]
    pub fn rados_conf_parse_argv_remainder(
        cluster: rados_t,
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
        remargv: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the cluster handle based on an environment variable\n\n The contents of the environment variable are parsed as if they were\n Ceph command line options. If var is NULL, the CEPH_ARGS\n environment variable is used.\n\n @pre rados_connect() has not been called on the cluster handle\n\n @note BUG: this is not threadsafe - it uses a static buffer\n\n @param cluster cluster handle to configure\n @param var name of the environment variable to read\n @returns 0 on success, negative error code on failure"]
    pub fn rados_conf_parse_env(
        cluster: rados_t,
        var: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a configuration option\n\n @pre rados_connect() has not been called on the cluster handle\n\n @param cluster cluster handle to configure\n @param option option to set\n @param value value of the option\n @returns 0 on success, negative error code on failure\n @returns -ENOENT when the option is not a Ceph configuration option"]
    pub fn rados_conf_set(
        cluster: rados_t,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the value of a configuration option\n\n @param cluster configuration to read\n @param option which option to read\n @param buf where to write the configuration value\n @param len the size of buf in bytes\n @returns 0 on success, negative error code on failure\n @returns -ENAMETOOLONG if the buffer is too short to contain the\n requested value"]
    pub fn rados_conf_get(
        cluster: rados_t,
        option: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read usage info about the cluster\n\n This tells you total space, space used, space available, and number\n of objects. These are not updated immediately when data is written,\n they are eventually consistent.\n\n @param cluster cluster to query\n @param result where to store the results\n @returns 0 on success, negative error code on failure"]
    pub fn rados_cluster_stat(
        cluster: rados_t,
        result: *mut rados_cluster_stat_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the fsid of the cluster as a hexadecimal string.\n\n The fsid is a unique id of an entire Ceph cluster.\n\n @param cluster where to get the fsid\n @param buf where to write the fsid\n @param len the size of buf in bytes (should be 37)\n @returns 0 on success, negative error code on failure\n @returns -ERANGE if the buffer is too short to contain the\n fsid"]
    pub fn rados_cluster_fsid(
        cluster: rados_t,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get/wait for the most recent osdmap\n\n @param cluster the cluster to shutdown\n @returns 0 on success, negative error code on failure"]
    pub fn rados_wait_for_latest_osdmap(cluster: rados_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List pools\n\n Gets a list of pool names as NULL-terminated strings.  The pool\n names will be placed in the supplied buffer one after another.\n After the last pool name, there will be two 0 bytes in a row.\n\n If len is too short to fit all the pool name entries we need, we will fill\n as much as we can.\n\n Buf may be null to determine the buffer size needed to list all pools.\n\n @param cluster cluster handle\n @param buf output buffer\n @param len output buffer length\n @returns length of the buffer we would need to list all pools"]
    pub fn rados_pool_list(
        cluster: rados_t,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List inconsistent placement groups of the given pool\n\n Gets a list of inconsistent placement groups as NULL-terminated strings.\n The placement group names will be placed in the supplied buffer one after\n another. After the last name, there will be two 0 types in a row.\n\n If len is too short to fit all the placement group entries we need, we  will\n fill as much as we can.\n\n @param cluster cluster handle\n @param pool pool ID\n @param buf output buffer\n @param len output buffer length\n @returns length of the buffer we would need to list all pools"]
    pub fn rados_inconsistent_pg_list(
        cluster: rados_t,
        pool: i64,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a configuration handle for a rados cluster handle\n\n This handle is valid only as long as the cluster handle is valid.\n\n @param cluster cluster handle\n @returns config handle for this cluster"]
    pub fn rados_cct(cluster: rados_t) -> rados_config_t;
}
unsafe extern "C" {
    #[doc = " Get a global id for current instance\n\n This id is a unique representation of current connection to the cluster\n\n @param cluster cluster handle\n @returns instance global id"]
    pub fn rados_get_instance_id(cluster: rados_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Gets the minimum compatible OSD version\n\n @param cluster cluster handle\n @param require_osd_release [out] minimum compatible OSD version\n  based upon the current features\n @returns 0 on sucess, negative error code on failure"]
    pub fn rados_get_min_compatible_osd(
        cluster: rados_t,
        require_osd_release: *mut i8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the minimum compatible client version\n\n @param cluster cluster handle\n @param min_compat_client [out] minimum compatible client version\n  based upon the current features\n @param require_min_compat_client [out] required minimum client version\n  based upon explicit setting\n @returns 0 on success, negative error code on failure"]
    pub fn rados_get_min_compatible_client(
        cluster: rados_t,
        min_compat_client: *mut i8,
        require_min_compat_client: *mut i8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create an io context\n\n The io context allows you to perform operations within a particular\n pool. For more details see rados_ioctx_t.\n\n @param cluster which cluster the pool is in\n @param pool_name name of the pool\n @param ioctx where to store the io context\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_create(
        cluster: rados_t,
        pool_name: *const ::std::os::raw::c_char,
        ioctx: *mut rados_ioctx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_ioctx_create2(
        cluster: rados_t,
        pool_id: i64,
        ioctx: *mut rados_ioctx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The opposite of rados_ioctx_create\n\n This just tells librados that you no longer need to use the io context.\n It may not be freed immediately if there are pending asynchronous\n requests on it, but you should not use an io context again after\n calling this function on it.\n\n @warning This does not guarantee any asynchronous\n writes have completed. You must call rados_aio_flush()\n on the io context before destroying it to do that.\n\n @warning If this ioctx is used by rados_watch, the caller needs to\n be sure that all registered watches are disconnected via\n rados_unwatch() and that rados_watch_flush() is called.  This\n ensures that a racing watch callback does not make use of a\n destroyed ioctx.\n\n @param io the io context to dispose of"]
    pub fn rados_ioctx_destroy(io: rados_ioctx_t);
}
unsafe extern "C" {
    #[doc = " Get configuration handle for a pool handle\n\n @param io pool handle\n @returns rados_config_t for this cluster"]
    pub fn rados_ioctx_cct(io: rados_ioctx_t) -> rados_config_t;
}
unsafe extern "C" {
    #[doc = " Get the cluster handle used by this rados_ioctx_t\n Note that this is a weak reference, and should not\n be destroyed via rados_shutdown().\n\n @param io the io context\n @returns the cluster handle for this io context"]
    pub fn rados_ioctx_get_cluster(io: rados_ioctx_t) -> rados_t;
}
unsafe extern "C" {
    #[doc = " Get pool usage statistics\n\n Fills in a rados_pool_stat_t after querying the cluster.\n\n @param io determines which pool to query\n @param stats where to store the results\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_pool_stat(
        io: rados_ioctx_t,
        stats: *mut rados_pool_stat_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the id of a pool\n\n @param cluster which cluster the pool is in\n @param pool_name which pool to look up\n @returns id of the pool\n @returns -ENOENT if the pool is not found"]
    pub fn rados_pool_lookup(cluster: rados_t, pool_name: *const ::std::os::raw::c_char) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the name of a pool\n\n @param cluster which cluster the pool is in\n @param id the id of the pool\n @param buf where to store the pool name\n @param maxlen size of buffer where name will be stored\n @returns length of string stored, or -ERANGE if buffer too small"]
    pub fn rados_pool_reverse_lookup(
        cluster: rados_t,
        id: i64,
        buf: *mut ::std::os::raw::c_char,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a pool with default settings\n\n The default crush rule is rule 0.\n\n @param cluster the cluster in which the pool will be created\n @param pool_name the name of the new pool\n @returns 0 on success, negative error code on failure"]
    pub fn rados_pool_create(
        cluster: rados_t,
        pool_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a pool owned by a specific auid.\n\n DEPRECATED: auid support has been removed, and this call will be removed in a future\n release.\n\n @param cluster the cluster in which the pool will be created\n @param pool_name the name of the new pool\n @param auid the id of the owner of the new pool\n @returns 0 on success, negative error code on failure"]
    pub fn rados_pool_create_with_auid(
        cluster: rados_t,
        pool_name: *const ::std::os::raw::c_char,
        auid: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a pool with a specific CRUSH rule\n\n @param cluster the cluster in which the pool will be created\n @param pool_name the name of the new pool\n @param crush_rule_num which rule to use for placement in the new pool1\n @returns 0 on success, negative error code on failure"]
    pub fn rados_pool_create_with_crush_rule(
        cluster: rados_t,
        pool_name: *const ::std::os::raw::c_char,
        crush_rule_num: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a pool with a specific CRUSH rule and auid\n\n DEPRECATED: auid support has been removed and this call will be removed\n in a future release.\n\n This is a combination of rados_pool_create_with_crush_rule() and\n rados_pool_create_with_auid().\n\n @param cluster the cluster in which the pool will be created\n @param pool_name the name of the new pool\n @param crush_rule_num which rule to use for placement in the new pool2\n @param auid the id of the owner of the new pool\n @returns 0 on success, negative error code on failure"]
    pub fn rados_pool_create_with_all(
        cluster: rados_t,
        pool_name: *const ::std::os::raw::c_char,
        auid: u64,
        crush_rule_num: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Returns the pool that is the base tier for this pool.\n\n The return value is the ID of the pool that should be used to read from/write to.\n If tiering is not set up for the pool, returns \\c pool.\n\n @param cluster the cluster the pool is in\n @param pool ID of the pool to query\n @param base_tier [out] base tier, or \\c pool if tiering is not configured\n @returns 0 on success, negative error code on failure"]
    pub fn rados_pool_get_base_tier(
        cluster: rados_t,
        pool: i64,
        base_tier: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a pool and all data inside it\n\n The pool is removed from the cluster immediately,\n but the actual data is deleted in the background.\n\n @param cluster the cluster the pool is in\n @param pool_name which pool to delete\n @returns 0 on success, negative error code on failure"]
    pub fn rados_pool_delete(
        cluster: rados_t,
        pool_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Attempt to change an io context's associated auid \"owner\"\n\n DEPRECATED: auid support has been removed and this call has no effect.\n\n Requires that you have write permission on both the current and new\n auid.\n\n @param io reference to the pool to change.\n @param auid the auid you wish the io to have.\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_pool_set_auid(io: rados_ioctx_t, auid: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the auid of a pool\n\n DEPRECATED: auid support has been removed and this call always reports\n CEPH_AUTH_UID_DEFAULT (-1).\n\n @param io pool to query\n @param auid where to store the auid\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_pool_get_auid(io: rados_ioctx_t, auid: *mut u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_ioctx_pool_requires_alignment(io: rados_ioctx_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test whether the specified pool requires alignment or not.\n\n @param io pool to query\n @param req 1 if alignment is supported, 0 if not.\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_pool_requires_alignment2(
        io: rados_ioctx_t,
        req: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_ioctx_pool_required_alignment(io: rados_ioctx_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the alignment flavor of a pool\n\n @param io pool to query\n @param alignment where to store the alignment flavor\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_pool_required_alignment2(
        io: rados_ioctx_t,
        alignment: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the pool id of the io context\n\n @param io the io context to query\n @returns the id of the pool the io context uses"]
    pub fn rados_ioctx_get_id(io: rados_ioctx_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Get the pool name of the io context\n\n @param io the io context to query\n @param buf pointer to buffer where name will be stored\n @param maxlen size of buffer where name will be stored\n @returns length of string stored, or -ERANGE if buffer too small"]
    pub fn rados_ioctx_get_pool_name(
        io: rados_ioctx_t,
        buf: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the key for mapping objects to pgs within an io context.\n\n The key is used instead of the object name to determine which\n placement groups an object is put in. This affects all subsequent\n operations of the io context - until a different locator key is\n set, all objects in this io context will be placed in the same pg.\n\n @param io the io context to change\n @param key the key to use as the object locator, or NULL to discard\n any previously set key"]
    pub fn rados_ioctx_locator_set_key(io: rados_ioctx_t, key: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Set the namespace for objects within an io context\n\n The namespace specification further refines a pool into different\n domains.  The mapping of objects to pgs is also based on this\n value.\n\n @param io the io context to change\n @param nspace the name to use as the namespace, or NULL use the\n default namespace"]
    pub fn rados_ioctx_set_namespace(io: rados_ioctx_t, nspace: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Get the namespace for objects within the io context\n\n @param io the io context to query\n @param buf pointer to buffer where name will be stored\n @param maxlen size of buffer where name will be stored\n @returns length of string stored, or -ERANGE if buffer too small"]
    pub fn rados_ioctx_get_namespace(
        io: rados_ioctx_t,
        buf: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @name Listing Objects\n @{\n/\n/**\n Start listing objects in a pool\n\n @param io the pool to list from\n @param ctx the handle to store list context in\n @returns 0 on success, negative error code on failure"]
    pub fn rados_nobjects_list_open(
        io: rados_ioctx_t,
        ctx: *mut rados_list_ctx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return hash position of iterator, rounded to the current PG\n\n @param ctx iterator marking where you are in the listing\n @returns current hash position, rounded to the current pg"]
    pub fn rados_nobjects_list_get_pg_hash_position(ctx: rados_list_ctx_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Reposition object iterator to a different hash position\n\n @param ctx iterator marking where you are in the listing\n @param pos hash position to move to\n @returns actual (rounded) position we moved to"]
    pub fn rados_nobjects_list_seek(ctx: rados_list_ctx_t, pos: u32) -> u32;
}
unsafe extern "C" {
    #[doc = " Reposition object iterator to a different position\n\n @param ctx iterator marking where you are in the listing\n @param cursor position to move to\n @returns rounded position we moved to"]
    pub fn rados_nobjects_list_seek_cursor(
        ctx: rados_list_ctx_t,
        cursor: rados_object_list_cursor,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " Reposition object iterator to a different position\n\n The returned handle must be released with rados_object_list_cursor_free().\n\n @param ctx iterator marking where you are in the listing\n @param cursor where to store cursor\n @returns 0 on success, negative error code on failure"]
    pub fn rados_nobjects_list_get_cursor(
        ctx: rados_list_ctx_t,
        cursor: *mut rados_object_list_cursor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the next object name and locator in the pool\n\n *entry and *key are valid until next call to rados_nobjects_list_*\n\n @param ctx iterator marking where you are in the listing\n @param entry where to store the name of the entry\n @param key where to store the object locator (set to NULL to ignore)\n @param nspace where to store the object namespace (set to NULL to ignore)\n @returns 0 on success, negative error code on failure\n @returns -ENOENT when there are no more objects to list"]
    pub fn rados_nobjects_list_next(
        ctx: rados_list_ctx_t,
        entry: *mut *const ::std::os::raw::c_char,
        key: *mut *const ::std::os::raw::c_char,
        nspace: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the next object name, locator and their sizes in the pool\n\n The sizes allow to list objects with \\0 (the NUL character)\n in .e.g *entry. Is is unusual see such object names but a bug\n in a client has risen the need to handle them as well.\n *entry and *key are valid until next call to rados_nobjects_list_*\n\n @param ctx iterator marking where you are in the listing\n @param entry where to store the name of the entry\n @param key where to store the object locator (set to NULL to ignore)\n @param nspace where to store the object namespace (set to NULL to ignore)\n @param entry_size where to store the size of name of the entry\n @param key_size where to store the size of object locator (set to NULL to ignore)\n @param nspace_size where to store the size of object namespace (set to NULL to ignore)\n @returns 0 on success, negative error code on failure\n @returns -ENOENT when there are no more objects to list"]
    pub fn rados_nobjects_list_next2(
        ctx: rados_list_ctx_t,
        entry: *mut *const ::std::os::raw::c_char,
        key: *mut *const ::std::os::raw::c_char,
        nspace: *mut *const ::std::os::raw::c_char,
        entry_size: *mut usize,
        key_size: *mut usize,
        nspace_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close the object listing handle.\n\n This should be called when the handle is no longer needed.\n The handle should not be used after it has been closed.\n\n @param ctx the handle to close"]
    pub fn rados_nobjects_list_close(ctx: rados_list_ctx_t);
}
unsafe extern "C" {
    #[doc = " Get cursor handle pointing to the *beginning* of a pool.\n\n This is an opaque handle pointing to the start of a pool.  It must\n be released with rados_object_list_cursor_free().\n\n @param io ioctx for the pool\n @returns handle for the pool, NULL on error (pool does not exist)"]
    pub fn rados_object_list_begin(io: rados_ioctx_t) -> rados_object_list_cursor;
}
unsafe extern "C" {
    #[doc = " Get cursor handle pointing to the *end* of a pool.\n\n This is an opaque handle pointing to the start of a pool.  It must\n be released with rados_object_list_cursor_free().\n\n @param io ioctx for the pool\n @returns handle for the pool, NULL on error (pool does not exist)"]
    pub fn rados_object_list_end(io: rados_ioctx_t) -> rados_object_list_cursor;
}
unsafe extern "C" {
    #[doc = " Check if a cursor has reached the end of a pool\n\n @param io ioctx\n @param cur cursor\n @returns 1 if the cursor has reached the end of the pool, 0 otherwise"]
    pub fn rados_object_list_is_end(
        io: rados_ioctx_t,
        cur: rados_object_list_cursor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release a cursor\n\n Release a cursor.  The handle may not be used after this point.\n\n @param io ioctx\n @param cur cursor"]
    pub fn rados_object_list_cursor_free(io: rados_ioctx_t, cur: rados_object_list_cursor);
}
unsafe extern "C" {
    #[doc = " Compare two cursor positions\n\n Compare two cursors, and indicate whether the first cursor precedes,\n matches, or follows the second.\n\n @param io ioctx\n @param lhs first cursor\n @param rhs second cursor\n @returns -1, 0, or 1 for lhs < rhs, lhs == rhs, or lhs > rhs"]
    pub fn rados_object_list_cursor_cmp(
        io: rados_ioctx_t,
        lhs: rados_object_list_cursor,
        rhs: rados_object_list_cursor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @return the number of items set in the results array"]
    pub fn rados_object_list(
        io: rados_ioctx_t,
        start: rados_object_list_cursor,
        finish: rados_object_list_cursor,
        result_size: usize,
        filter_buf: *const ::std::os::raw::c_char,
        filter_buf_len: usize,
        results: *mut rados_object_list_item,
        next: *mut rados_object_list_cursor,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_object_list_free(result_size: usize, results: *mut rados_object_list_item);
}
unsafe extern "C" {
    #[doc = " Obtain cursors delineating a subset of a range.  Use this\n when you want to split up the work of iterating over the\n global namespace.  Expected use case is when you are iterating\n in parallel, with `m` workers, and each worker taking an id `n`.\n\n @param io ioctx\n @param start start of the range to be sliced up (inclusive)\n @param finish end of the range to be sliced up (exclusive)\n @param n which of the m chunks you would like to get cursors for\n @param m how many chunks to divide start-finish into\n @param split_start cursor populated with start of the subrange (inclusive)\n @param split_finish cursor populated with end of the subrange (exclusive)"]
    pub fn rados_object_list_slice(
        io: rados_ioctx_t,
        start: rados_object_list_cursor,
        finish: rados_object_list_cursor,
        n: usize,
        m: usize,
        split_start: *mut rados_object_list_cursor,
        split_finish: *mut rados_object_list_cursor,
    );
}
unsafe extern "C" {
    #[doc = " Create a pool-wide snapshot\n\n @param io the pool to snapshot\n @param snapname the name of the snapshot\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_snap_create(
        io: rados_ioctx_t,
        snapname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete a pool snapshot\n\n @param io the pool to delete the snapshot from\n @param snapname which snapshot to delete\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_snap_remove(
        io: rados_ioctx_t,
        snapname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Rollback an object to a pool snapshot\n\n The contents of the object will be the same as\n when the snapshot was taken.\n\n @param io the pool in which the object is stored\n @param oid the name of the object to rollback\n @param snapname which snapshot to rollback to\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_snap_rollback(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        snapname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning Deprecated: Use rados_ioctx_snap_rollback() instead"]
    pub fn rados_rollback(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        snapname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the snapshot from which reads are performed.\n\n Subsequent reads will return data as it was at the time of that\n snapshot.\n\n @param io the io context to change\n @param snap the id of the snapshot to set, or LIBRADOS_SNAP_HEAD for no\n snapshot (i.e. normal operation)"]
    pub fn rados_ioctx_snap_set_read(io: rados_ioctx_t, snap: rados_snap_t);
}
unsafe extern "C" {
    #[doc = " Allocate an ID for a self-managed snapshot\n\n Get a unique ID to put in the snaphot context to create a\n snapshot. A clone of an object is not created until a write with\n the new snapshot context is completed.\n\n @param io the pool in which the snapshot will exist\n @param snapid where to store the newly allocated snapshot ID\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_selfmanaged_snap_create(
        io: rados_ioctx_t,
        snapid: *mut rados_snap_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_aio_ioctx_selfmanaged_snap_create(
        io: rados_ioctx_t,
        snapid: *mut rados_snap_t,
        completion: rados_completion_t,
    );
}
unsafe extern "C" {
    #[doc = " Remove a self-managed snapshot\n\n This increases the snapshot sequence number, which will cause\n snapshots to be removed lazily.\n\n @param io the pool in which the snapshot will exist\n @param snapid where to store the newly allocated snapshot ID\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_selfmanaged_snap_remove(
        io: rados_ioctx_t,
        snapid: rados_snap_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_aio_ioctx_selfmanaged_snap_remove(
        io: rados_ioctx_t,
        snapid: rados_snap_t,
        completion: rados_completion_t,
    );
}
unsafe extern "C" {
    #[doc = " Rollback an object to a self-managed snapshot\n\n The contents of the object will be the same as\n when the snapshot was taken.\n\n @param io the pool in which the object is stored\n @param oid the name of the object to rollback\n @param snapid which snapshot to rollback to\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_selfmanaged_snap_rollback(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        snapid: rados_snap_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the snapshot context for use when writing to objects\n\n This is stored in the io context, and applies to all future writes.\n\n @param io the io context to change\n @param seq the newest snapshot sequence number for the pool\n @param snaps array of snapshots in sorted by descending id\n @param num_snaps how many snaphosts are in the snaps array\n @returns 0 on success, negative error code on failure\n @returns -EINVAL if snaps are not in descending order"]
    pub fn rados_ioctx_selfmanaged_snap_set_write_ctx(
        io: rados_ioctx_t,
        seq: rados_snap_t,
        snaps: *mut rados_snap_t,
        num_snaps: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List all the ids of pool snapshots\n\n If the output array does not have enough space to fit all the\n snapshots, -ERANGE is returned and the caller should retry with a\n larger array.\n\n @param io the pool to read from\n @param snaps where to store the results\n @param maxlen the number of rados_snap_t that fit in the snaps array\n @returns number of snapshots on success, negative error code on failure\n @returns -ERANGE is returned if the snaps array is too short"]
    pub fn rados_ioctx_snap_list(
        io: rados_ioctx_t,
        snaps: *mut rados_snap_t,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the id of a pool snapshot\n\n @param io the pool to read from\n @param name the snapshot to find\n @param id where to store the result\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_snap_lookup(
        io: rados_ioctx_t,
        name: *const ::std::os::raw::c_char,
        id: *mut rados_snap_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the name of a pool snapshot\n\n @param io the pool to read from\n @param id the snapshot to find\n @param name where to store the result\n @param maxlen the size of the name array\n @returns 0 on success, negative error code on failure\n @returns -ERANGE if the name array is too small"]
    pub fn rados_ioctx_snap_get_name(
        io: rados_ioctx_t,
        id: rados_snap_t,
        name: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find when a pool snapshot occurred\n\n @param io the pool the snapshot was taken in\n @param id the snapshot to lookup\n @param t where to store the result\n @returns 0 on success, negative error code on failure"]
    pub fn rados_ioctx_snap_get_stamp(
        io: rados_ioctx_t,
        id: rados_snap_t,
        t: *mut time_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the version of the last object read or written to.\n\n This exposes the internal version number of the last object read or\n written via this io context\n\n @param io the io context to check\n @returns last read or written object version"]
    pub fn rados_get_last_version(io: rados_ioctx_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Write *len* bytes from *buf* into the *oid* object, starting at\n offset *off*. The value of *len* must be <= UINT_MAX/2.\n\n @note This will never return a positive value not equal to len.\n @param io the io context in which the write will occur\n @param oid name of the object\n @param buf data to write\n @param len length of the data, in bytes\n @param off byte offset in the object to begin writing at\n @returns 0 on success, negative error code on failure"]
    pub fn rados_write(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write *len* bytes from *buf* into the *oid* object. The value of\n *len* must be <= UINT_MAX/2.\n\n The object is filled with the provided data. If the object exists,\n it is atomically truncated and then written.\n\n @param io the io context in which the write will occur\n @param oid name of the object\n @param buf data to write\n @param len length of the data, in bytes\n @returns 0 on success, negative error code on failure"]
    pub fn rados_write_full(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Write the same *data_len* bytes from *buf* multiple times into the\n *oid* object. *write_len* bytes are written in total, which must be\n a multiple of *data_len*. The value of *write_len* and *data_len*\n must be <= UINT_MAX/2.\n\n @param io the io context in which the write will occur\n @param oid name of the object\n @param buf data to write\n @param data_len length of the data, in bytes\n @param write_len the total number of bytes to write\n @param off byte offset in the object to begin writing at\n @returns 0 on success, negative error code on failure"]
    pub fn rados_writesame(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        data_len: usize,
        write_len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Append *len* bytes from *buf* into the *oid* object. The value of\n *len* must be <= UINT_MAX/2.\n\n @param io the context to operate in\n @param oid the name of the object\n @param buf the data to append\n @param len length of buf (in bytes)\n @returns 0 on success, negative error code on failure"]
    pub fn rados_append(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read data from an object\n\n The io context determines the snapshot to read from, if any was set\n by rados_ioctx_snap_set_read().\n\n @param io the context in which to perform the read\n @param oid the name of the object to read from\n @param buf where to store the results\n @param len the number of bytes to read\n @param off the offset to start reading from in the object\n @returns number of bytes read on success, negative error code on\n failure"]
    pub fn rados_read(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compute checksum from object data\n\n The io context determines the snapshot to checksum, if any was set\n by rados_ioctx_snap_set_read(). The length of the init_value and\n resulting checksum are dependent upon the checksum type:\n\n    XXHASH64: le64\n    XXHASH32: le32\n    CRC32C:\tle32\n\n The checksum result is encoded the following manner:\n\n    le32 num_checksum_chunks\n    {\n      leXX checksum for chunk (where XX = appropriate size for the checksum type)\n    } * num_checksum_chunks\n\n @param io the context in which to perform the checksum\n @param oid the name of the object to checksum\n @param type the checksum algorithm to utilize\n @param init_value the init value for the algorithm\n @param init_value_len the length of the init value\n @param len the number of bytes to checksum\n @param off the offset to start checksumming in the object\n @param chunk_size optional length-aligned chunk size for checksums\n @param pchecksum where to store the checksum result\n @param checksum_len the number of bytes available for the result\n @return negative error code on failure"]
    pub fn rados_checksum(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        type_: rados_checksum_type_t,
        init_value: *const ::std::os::raw::c_char,
        init_value_len: usize,
        len: usize,
        off: u64,
        chunk_size: usize,
        pchecksum: *mut ::std::os::raw::c_char,
        checksum_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete an object\n\n @note This does not delete any snapshots of the object.\n\n @param io the pool to delete the object from\n @param oid the name of the object to delete\n @returns 0 on success, negative error code on failure"]
    pub fn rados_remove(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Resize an object\n\n If this enlarges the object, the new area is logically filled with\n zeroes. If this shrinks the object, the excess data is removed.\n\n @param io the context in which to truncate\n @param oid the name of the object\n @param size the new size of the object in bytes\n @returns 0 on success, negative error code on failure"]
    pub fn rados_trunc(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        size: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Compare an on-disk object range with a buffer\n\n @param io the context in which to perform the comparison\n @param o name of the object\n @param cmp_buf buffer containing bytes to be compared with object contents\n @param cmp_len length to compare and size of @c cmp_buf in bytes\n @param off object byte offset at which to start the comparison\n @returns 0 on success, negative error code on failure,\n  (-MAX_ERRNO - mismatch_off) on mismatch"]
    pub fn rados_cmpext(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        cmp_buf: *const ::std::os::raw::c_char,
        cmp_len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the value of an extended attribute on an object.\n\n @param io the context in which the attribute is read\n @param o name of the object\n @param name which extended attribute to read\n @param buf where to store the result\n @param len size of buf in bytes\n @returns length of xattr value on success, negative error code on failure"]
    pub fn rados_getxattr(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set an extended attribute on an object.\n\n @param io the context in which xattr is set\n @param o name of the object\n @param name which extended attribute to set\n @param buf what to store in the xattr\n @param len the number of bytes in buf\n @returns 0 on success, negative error code on failure"]
    pub fn rados_setxattr(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete an extended attribute from an object.\n\n @param io the context in which to delete the xattr\n @param o the name of the object\n @param name which xattr to delete\n @returns 0 on success, negative error code on failure"]
    pub fn rados_rmxattr(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start iterating over xattrs on an object.\n\n @post iter is a valid iterator\n\n @param io the context in which to list xattrs\n @param oid name of the object\n @param iter where to store the iterator\n @returns 0 on success, negative error code on failure"]
    pub fn rados_getxattrs(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        iter: *mut rados_xattrs_iter_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the next xattr on the object\n\n @pre iter is a valid iterator\n\n @post name is the NULL-terminated name of the next xattr, and val\n contains the value of the xattr, which is of length len. If the end\n of the list has been reached, name and val are NULL, and len is 0.\n\n @param iter iterator to advance\n @param name where to store the name of the next xattr\n @param val where to store the value of the next xattr\n @param len the number of bytes in val\n @returns 0 on success, negative error code on failure"]
    pub fn rados_getxattrs_next(
        iter: rados_xattrs_iter_t,
        name: *mut *const ::std::os::raw::c_char,
        val: *mut *const ::std::os::raw::c_char,
        len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close the xattr iterator.\n\n iter should not be used after this is called.\n\n @param iter the iterator to close"]
    pub fn rados_getxattrs_end(iter: rados_xattrs_iter_t);
}
unsafe extern "C" {
    #[doc = " Get the next omap key/value pair on the object\n\n @pre iter is a valid iterator\n\n @post key and val are the next key/value pair. key is\n null-terminated, and val has length len. If the end of the list has\n been reached, key and val are NULL, and len is 0. key and val will\n not be accessible after rados_omap_get_end() is called on iter, so\n if they are needed after that they should be copied.\n\n @param iter iterator to advance\n @param key where to store the key of the next omap entry\n @param val where to store the value of the next omap entry\n @param len where to store the number of bytes in val\n @returns 0 on success, negative error code on failure"]
    pub fn rados_omap_get_next(
        iter: rados_omap_iter_t,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
        len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the next omap key/value pair on the object. Note that it's\n perfectly safe to mix calls to rados_omap_get_next and\n rados_omap_get_next2.\n\n @pre iter is a valid iterator\n\n @post key and val are the next key/value pair. key has length\n keylen and val has length vallen. If the end of the list has\n been reached, key and val are NULL, and keylen and vallen is 0.\n key and val will not be accessible after rados_omap_get_end()\n is called on iter, so if they are needed after that they\n should be copied.\n\n @param iter iterator to advance\n @param key where to store the key of the next omap entry\n @param val where to store the value of the next omap entry\n @param key_len where to store the number of bytes in key\n @param val_len where to store the number of bytes in val\n @returns 0 on success, negative error code on failure"]
    pub fn rados_omap_get_next2(
        iter: rados_omap_iter_t,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
        key_len: *mut usize,
        val_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return number of elements in the iterator\n\n @param iter the iterator of which to return the size"]
    pub fn rados_omap_iter_size(iter: rados_omap_iter_t) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Close the omap iterator.\n\n iter should not be used after this is called.\n\n @param iter the iterator to close"]
    pub fn rados_omap_get_end(iter: rados_omap_iter_t);
}
unsafe extern "C" {
    #[doc = " Get object size and most recent update time from the OSD.\n\n @param io ioctx\n @param o object name\n @param psize where to store object size\n @param pmtime where to store modification time\n @returns 0 on success, negative error code on failure"]
    pub fn rados_stat(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        psize: *mut u64,
        pmtime: *mut time_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_stat2(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        psize: *mut u64,
        pmtime: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Execute an OSD class method on an object\n\n The OSD has a plugin mechanism for performing complicated\n operations on an object atomically. These plugins are called\n classes. This function allows librados users to call the custom\n methods. The input and output formats are defined by the class.\n Classes in ceph.git can be found in src/cls subdirectories\n\n @param io the context in which to call the method\n @param oid the object to call the method on\n @param cls the name of the class\n @param method the name of the method\n @param in_buf where to find input\n @param in_len length of in_buf in bytes\n @param buf where to store output\n @param out_len length of buf in bytes\n @returns the length of the output, or\n -ERANGE if out_buf does not have enough space to store it (For methods that return data). For\n methods that don't return data, the return value is\n method-specific."]
    pub fn rados_exec(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        cls: *const ::std::os::raw::c_char,
        method: *const ::std::os::raw::c_char,
        in_buf: *const ::std::os::raw::c_char,
        in_len: usize,
        buf: *mut ::std::os::raw::c_char,
        out_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @typedef rados_callback_t\n Callbacks for asynchrous operations take two parameters:\n - cb the completion that has finished\n - arg application defined data made available to the callback function"]
pub type rados_callback_t = ::std::option::Option<
    unsafe extern "C" fn(cb: rados_completion_t, arg: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " Constructs a completion to use with asynchronous operations\n\n The complete and safe callbacks correspond to operations being\n acked and committed, respectively. The callbacks are called in\n order of receipt, so the safe callback may be triggered before the\n complete callback, and vice versa. This is affected by journalling\n on the OSDs.\n\n TODO: more complete documentation of this elsewhere (in the RADOS docs?)\n\n @note Read operations only get a complete callback.\n @note BUG: this should check for ENOMEM instead of throwing an exception\n\n @param cb_arg application-defined data passed to the callback functions\n @param cb_complete the function to be called when the operation is\n in memory on all replicas\n @param cb_safe the function to be called when the operation is on\n stable storage on all replicas\n @param pc where to store the completion\n @returns 0"]
    pub fn rados_aio_create_completion(
        cb_arg: *mut ::std::os::raw::c_void,
        cb_complete: rados_callback_t,
        cb_safe: rados_callback_t,
        pc: *mut rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Constructs a completion to use with asynchronous operations\n\n The complete callback corresponds to operation being acked.\n\n @note BUG: this should check for ENOMEM instead of throwing an exception\n\n @param cb_arg application-defined data passed to the callback functions\n @param cb_complete the function to be called when the operation is committed\n on all replicas\n @param pc where to store the completion\n @returns 0"]
    pub fn rados_aio_create_completion2(
        cb_arg: *mut ::std::os::raw::c_void,
        cb_complete: rados_callback_t,
        pc: *mut rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Block until an operation completes\n\n This means it is in memory on all replicas.\n\n @note BUG: this should be void\n\n @param c operation to wait for\n @returns 0"]
    pub fn rados_aio_wait_for_complete(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Block until an operation is safe\n\n This means it is on stable storage on all replicas.\n\n @note BUG: this should be void\n\n @param c operation to wait for\n @returns 0"]
    pub fn rados_aio_wait_for_safe(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Has an asynchronous operation completed?\n\n @warning This does not imply that the complete callback has\n finished\n\n @param c async operation to inspect\n @returns whether c is complete"]
    pub fn rados_aio_is_complete(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is an asynchronous operation safe?\n\n @warning This does not imply that the safe callback has\n finished\n\n @param c async operation to inspect\n @returns whether c is safe"]
    pub fn rados_aio_is_safe(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Block until an operation completes and callback completes\n\n This means it is in memory on all replicas and can be read.\n\n @note BUG: this should be void\n\n @param c operation to wait for\n @returns 0"]
    pub fn rados_aio_wait_for_complete_and_cb(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Block until an operation is safe and callback has completed\n\n This means it is on stable storage on all replicas.\n\n @note BUG: this should be void\n\n @param c operation to wait for\n @returns 0"]
    pub fn rados_aio_wait_for_safe_and_cb(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Has an asynchronous operation and callback completed\n\n @param c async operation to inspect\n @returns whether c is complete"]
    pub fn rados_aio_is_complete_and_cb(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Is an asynchronous operation safe and has the callback completed\n\n @param c async operation to inspect\n @returns whether c is safe"]
    pub fn rados_aio_is_safe_and_cb(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the return value of an asychronous operation\n\n The return value is set when the operation is complete or safe,\n whichever comes first.\n\n @pre The operation is safe or complete\n\n @note BUG: complete callback may never be called when the safe\n message is received before the complete message\n\n @param c async operation to inspect\n @returns return value of the operation"]
    pub fn rados_aio_get_return_value(c: rados_completion_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the internal object version of the target of an asychronous operation\n\n The return value is set when the operation is complete or safe,\n whichever comes first.\n\n @pre The operation is safe or complete\n\n @note BUG: complete callback may never be called when the safe\n message is received before the complete message\n\n @param c async operation to inspect\n @returns version number of the asychronous operation's target"]
    pub fn rados_aio_get_version(c: rados_completion_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Release a completion\n\n Call this when you no longer need the completion. It may not be\n freed immediately if the operation is not acked and committed.\n\n @param c completion to release"]
    pub fn rados_aio_release(c: rados_completion_t);
}
unsafe extern "C" {
    #[doc = " Write data to an object asynchronously\n\n Queues the write and returns. The return value of the completion\n will be 0 on success, negative error code on failure.\n\n @param io the context in which the write will occur\n @param oid name of the object\n @param completion what to do when the write is safe and complete\n @param buf data to write\n @param len length of the data, in bytes\n @param off byte offset in the object to begin writing at\n @returns 0 on success, -EROFS if the io context specifies a snap_seq\n other than LIBRADOS_SNAP_HEAD"]
    pub fn rados_aio_write(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        buf: *const ::std::os::raw::c_char,
        len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously append data to an object\n\n Queues the append and returns.\n\n The return value of the completion will be 0 on success, negative\n error code on failure.\n\n @param io the context to operate in\n @param oid the name of the object\n @param completion what to do when the append is safe and complete\n @param buf the data to append\n @param len length of buf (in bytes)\n @returns 0 on success, -EROFS if the io context specifies a snap_seq\n other than LIBRADOS_SNAP_HEAD"]
    pub fn rados_aio_append(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously write an entire object\n\n The object is filled with the provided data. If the object exists,\n it is atomically truncated and then written.\n Queues the write_full and returns.\n\n The return value of the completion will be 0 on success, negative\n error code on failure.\n\n @param io the io context in which the write will occur\n @param oid name of the object\n @param completion what to do when the write_full is safe and complete\n @param buf data to write\n @param len length of the data, in bytes\n @returns 0 on success, -EROFS if the io context specifies a snap_seq\n other than LIBRADOS_SNAP_HEAD"]
    pub fn rados_aio_write_full(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously write the same buffer multiple times\n\n Queues the writesame and returns.\n\n The return value of the completion will be 0 on success, negative\n error code on failure.\n\n @param io the io context in which the write will occur\n @param oid name of the object\n @param completion what to do when the writesame is safe and complete\n @param buf data to write\n @param data_len length of the data, in bytes\n @param write_len the total number of bytes to write\n @param off byte offset in the object to begin writing at\n @returns 0 on success, -EROFS if the io context specifies a snap_seq\n other than LIBRADOS_SNAP_HEAD"]
    pub fn rados_aio_writesame(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        buf: *const ::std::os::raw::c_char,
        data_len: usize,
        write_len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously remove an object\n\n Queues the remove and returns.\n\n The return value of the completion will be 0 on success, negative\n error code on failure.\n\n @param io the context to operate in\n @param oid the name of the object\n @param completion what to do when the remove is safe and complete\n @returns 0 on success, -EROFS if the io context specifies a snap_seq\n other than LIBRADOS_SNAP_HEAD"]
    pub fn rados_aio_remove(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously read data from an object\n\n The io context determines the snapshot to read from, if any was set\n by rados_ioctx_snap_set_read().\n\n The return value of the completion will be number of bytes read on\n success, negative error code on failure.\n\n @note only the 'complete' callback of the completion will be called.\n\n @param io the context in which to perform the read\n @param oid the name of the object to read from\n @param completion what to do when the read is complete\n @param buf where to store the results\n @param len the number of bytes to read\n @param off the offset to start reading from in the object\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_read(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Block until all pending writes in an io context are safe\n\n This is not equivalent to calling rados_aio_wait_for_safe() on all\n write completions, since this waits for the associated callbacks to\n complete as well.\n\n @note BUG: always returns 0, should be void or accept a timeout\n\n @param io the context to flush\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_flush(io: rados_ioctx_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Schedule a callback for when all currently pending\n aio writes are safe. This is a non-blocking version of\n rados_aio_flush().\n\n @param io the context to flush\n @param completion what to do when the writes are safe\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_flush_async(
        io: rados_ioctx_t,
        completion: rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously get object stats (size/mtime)\n\n @param io ioctx\n @param o object name\n @param completion what to do when the stat is complete\n @param psize where to store object size\n @param pmtime where to store modification time\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_stat(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        psize: *mut u64,
        pmtime: *mut time_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_aio_stat2(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        psize: *mut u64,
        pmtime: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously compare an on-disk object range with a buffer\n\n @param io the context in which to perform the comparison\n @param o the name of the object to compare with\n @param completion what to do when the comparison is complete\n @param cmp_buf buffer containing bytes to be compared with object contents\n @param cmp_len length to compare and size of @c cmp_buf in bytes\n @param off object byte offset at which to start the comparison\n @returns 0 on success, negative error code on failure,\n  (-MAX_ERRNO - mismatch_off) on mismatch"]
    pub fn rados_aio_cmpext(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        cmp_buf: *const ::std::os::raw::c_char,
        cmp_len: usize,
        off: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Cancel async operation\n\n @param io ioctx\n @param completion completion handle\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_cancel(
        io: rados_ioctx_t,
        completion: rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously execute an OSD class method on an object\n\n The OSD has a plugin mechanism for performing complicated\n operations on an object atomically. These plugins are called\n classes. This function allows librados users to call the custom\n methods. The input and output formats are defined by the class.\n Classes in ceph.git can be found in src/cls subdirectories\n\n @param io the context in which to call the method\n @param o name of the object\n @param completion what to do when the exec completes\n @param cls the name of the class\n @param method the name of the method\n @param in_buf where to find input\n @param in_len length of in_buf in bytes\n @param buf where to store output\n @param out_len length of buf in bytes\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_exec(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        cls: *const ::std::os::raw::c_char,
        method: *const ::std::os::raw::c_char,
        in_buf: *const ::std::os::raw::c_char,
        in_len: usize,
        buf: *mut ::std::os::raw::c_char,
        out_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously get the value of an extended attribute on an object.\n\n @param io the context in which the attribute is read\n @param o name of the object\n @param completion what to do when the getxattr completes\n @param name which extended attribute to read\n @param buf where to store the result\n @param len size of buf in bytes\n @returns length of xattr value on success, negative error code on failure"]
    pub fn rados_aio_getxattr(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously set an extended attribute on an object.\n\n @param io the context in which xattr is set\n @param o name of the object\n @param completion what to do when the setxattr completes\n @param name which extended attribute to set\n @param buf what to store in the xattr\n @param len the number of bytes in buf\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_setxattr(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        name: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously delete an extended attribute from an object.\n\n @param io the context in which to delete the xattr\n @param o the name of the object\n @param completion what to do when the rmxattr completes\n @param name which xattr to delete\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_rmxattr(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronously start iterating over xattrs on an object.\n\n @post iter is a valid iterator\n\n @param io the context in which to list xattrs\n @param oid name of the object\n @param completion what to do when the getxattrs completes\n @param iter where to store the iterator\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_getxattrs(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        iter: *mut rados_xattrs_iter_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @typedef rados_watchcb_t\n\n Callback activated when a notify is received on a watched\n object.\n\n @param opcode undefined\n @param ver version of the watched object\n @param arg application-specific data\n\n @note BUG: opcode is an internal detail that shouldn't be exposed\n @note BUG: ver is unused"]
pub type rados_watchcb_t = ::std::option::Option<
    unsafe extern "C" fn(opcode: u8, ver: u64, arg: *mut ::std::os::raw::c_void),
>;
#[doc = " @typedef rados_watchcb2_t\n\n Callback activated when a notify is received on a watched\n object.\n\n @param arg opaque user-defined value provided to rados_watch2()\n @param notify_id an id for this notify event\n @param handle the watcher handle we are notifying\n @param notifier_id the unique client id for the notifier\n @param data payload from the notifier\n @param data_len length of payload buffer"]
pub type rados_watchcb2_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        notify_id: u64,
        handle: u64,
        notifier_id: u64,
        data: *mut ::std::os::raw::c_void,
        data_len: usize,
    ),
>;
#[doc = " @typedef rados_watcherrcb_t\n\n Callback activated when we encounter an error with the watch session.\n This can happen when the location of the objects moves within the\n cluster and we fail to register our watch with the new object location,\n or when our connection with the object OSD is otherwise interrupted and\n we may have missed notify events.\n\n @param pre opaque user-defined value provided to rados_watch2()\n @param cookie the internal id assigned to the watch session\n @param err error code"]
pub type rados_watcherrcb_t = ::std::option::Option<
    unsafe extern "C" fn(pre: *mut ::std::os::raw::c_void, cookie: u64, err: ::std::os::raw::c_int),
>;
unsafe extern "C" {
    #[doc = " Register an interest in an object\n\n A watch operation registers the client as being interested in\n notifications on an object. OSDs keep track of watches on\n persistent storage, so they are preserved across cluster changes by\n the normal recovery process. If the client loses its connection to\n the primary OSD for a watched object, the watch will be removed\n after 30 seconds. Watches are automatically reestablished when a new\n connection is made, or a placement group switches OSDs.\n\n @note BUG: librados should provide a way for watchers to notice connection resets\n @note BUG: the ver parameter does not work, and -ERANGE will never be returned\n            (See URL tracker.ceph.com/issues/2592)\n\n @param io the pool the object is in\n @param o the object to watch\n @param ver expected version of the object\n @param cookie where to store the internal id assigned to this watch\n @param watchcb what to do when a notify is received on this object\n @param arg application defined data to pass when watchcb is called\n @returns 0 on success, negative error code on failure\n @returns -ERANGE if the version of the object is greater than ver"]
    pub fn rados_watch(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        ver: u64,
        cookie: *mut u64,
        watchcb: rados_watchcb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register an interest in an object\n\n A watch operation registers the client as being interested in\n notifications on an object. OSDs keep track of watches on\n persistent storage, so they are preserved across cluster changes by\n the normal recovery process. If the client loses its connection to the\n primary OSD for a watched object, the watch will be removed after\n a timeout configured with osd_client_watch_timeout.\n Watches are automatically reestablished when a new\n connection is made, or a placement group switches OSDs.\n\n @param io the pool the object is in\n @param o the object to watch\n @param cookie where to store the internal id assigned to this watch\n @param watchcb what to do when a notify is received on this object\n @param watcherrcb what to do when the watch session encounters an error\n @param arg opaque value to pass to the callback\n @returns 0 on success, negative error code on failure"]
    pub fn rados_watch2(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        cookie: *mut u64,
        watchcb: rados_watchcb2_t,
        watcherrcb: rados_watcherrcb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register an interest in an object\n\n A watch operation registers the client as being interested in\n notifications on an object. OSDs keep track of watches on\n persistent storage, so they are preserved across cluster changes by\n the normal recovery process. Watches are automatically reestablished when a new\n connection is made, or a placement group switches OSDs.\n\n @param io the pool the object is in\n @param o the object to watch\n @param cookie where to store the internal id assigned to this watch\n @param watchcb what to do when a notify is received on this object\n @param watcherrcb what to do when the watch session encounters an error\n @param timeout how many seconds the connection will keep after disconnection\n @param arg opaque value to pass to the callback\n @returns 0 on success, negative error code on failure"]
    pub fn rados_watch3(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        cookie: *mut u64,
        watchcb: rados_watchcb2_t,
        watcherrcb: rados_watcherrcb_t,
        timeout: u32,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronous register an interest in an object\n\n A watch operation registers the client as being interested in\n notifications on an object. OSDs keep track of watches on\n persistent storage, so they are preserved across cluster changes by\n the normal recovery process. If the client loses its connection to\n the primary OSD for a watched object, the watch will be removed\n after 30 seconds. Watches are automatically reestablished when a new\n connection is made, or a placement group switches OSDs.\n\n @param io the pool the object is in\n @param o the object to watch\n @param completion what to do when operation has been attempted\n @param handle where to store the internal id assigned to this watch\n @param watchcb what to do when a notify is received on this object\n @param watcherrcb what to do when the watch session encounters an error\n @param arg opaque value to pass to the callback\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_watch(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        handle: *mut u64,
        watchcb: rados_watchcb2_t,
        watcherrcb: rados_watcherrcb_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronous register an interest in an object\n\n A watch operation registers the client as being interested in\n notifications on an object. OSDs keep track of watches on\n persistent storage, so they are preserved across cluster changes by\n the normal recovery process. If the client loses its connection to\n the primary OSD for a watched object, the watch will be removed\n after the number of seconds that configured in timeout parameter.\n Watches are automatically reestablished when a new\n connection is made, or a placement group switches OSDs.\n\n @param io the pool the object is in\n @param o the object to watch\n @param completion what to do when operation has been attempted\n @param handle where to store the internal id assigned to this watch\n @param watchcb what to do when a notify is received on this object\n @param watcherrcb what to do when the watch session encounters an error\n @param timeout how many seconds the connection will keep after disconnection\n @param arg opaque value to pass to the callback\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_watch2(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        handle: *mut u64,
        watchcb: rados_watchcb2_t,
        watcherrcb: rados_watcherrcb_t,
        timeout: u32,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check on the status of a watch\n\n Return the number of milliseconds since the watch was last confirmed.\n Or, if there has been an error, return that.\n\n If there is an error, the watch is no longer valid, and should be\n destroyed with rados_unwatch2().  The the user is still interested\n in the object, a new watch should be created with rados_watch2().\n\n @param io the pool the object is in\n @param cookie the watch handle\n @returns ms since last confirmed on success, negative error code on failure"]
    pub fn rados_watch_check(io: rados_ioctx_t, cookie: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister an interest in an object\n\n Once this completes, no more notifies will be sent to us for this\n watch. This should be called to clean up unneeded watchers.\n\n @param io the pool the object is in\n @param o the name of the watched object (ignored)\n @param cookie which watch to unregister\n @returns 0 on success, negative error code on failure"]
    pub fn rados_unwatch(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        cookie: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister an interest in an object\n\n Once this completes, no more notifies will be sent to us for this\n watch. This should be called to clean up unneeded watchers.\n\n @param io the pool the object is in\n @param cookie which watch to unregister\n @returns 0 on success, negative error code on failure"]
    pub fn rados_unwatch2(io: rados_ioctx_t, cookie: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronous unregister an interest in an object\n\n Once this completes, no more notifies will be sent to us for this\n watch. This should be called to clean up unneeded watchers.\n\n @param io the pool the object is in\n @param completion what to do when operation has been attempted\n @param cookie which watch to unregister\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_unwatch(
        io: rados_ioctx_t,
        cookie: u64,
        completion: rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sychronously notify watchers of an object\n\n This blocks until all watchers of the object have received and\n reacted to the notify, or a timeout is reached.\n\n @note BUG: the timeout is not changeable via the C API\n @note BUG: the bufferlist is inaccessible in a rados_watchcb_t\n\n @param io the pool the object is in\n @param o the name of the object\n @param ver obsolete - just pass zero\n @param buf data to send to watchers\n @param buf_len length of buf in bytes\n @returns 0 on success, negative error code on failure"]
    pub fn rados_notify(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        ver: u64,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Sychronously notify watchers of an object\n\n This blocks until all watchers of the object have received and\n reacted to the notify, or a timeout is reached.\n\n The reply buffer is optional.  If specified, the client will get\n back an encoded buffer that includes the ids of the clients that\n acknowledged the notify as well as their notify ack payloads (if\n any).  Clients that timed out are not included.  Even clients that\n do not include a notify ack payload are included in the list but\n have a 0-length payload associated with them.  The format:\n\n    le32 num_acks\n    {\n      le64 gid     global id for the client (for client.1234 that's 1234)\n      le64 cookie  cookie for the client\n      le32 buflen  length of reply message buffer\n      u8 * buflen  payload\n    } * num_acks\n    le32 num_timeouts\n    {\n      le64 gid     global id for the client\n      le64 cookie  cookie for the client\n    } * num_timeouts\n\n Note: There may be multiple instances of the same gid if there are\n multiple watchers registered via the same client.\n\n Note: The buffer must be released with rados_buffer_free() when the\n user is done with it.\n\n Note: Since the result buffer includes clients that time out, it\n will be set even when rados_notify() returns an error code (like\n -ETIMEDOUT).\n\n @param io the pool the object is in\n @param completion what to do when operation has been attempted\n @param o the name of the object\n @param buf data to send to watchers\n @param buf_len length of buf in bytes\n @param timeout_ms notify timeout (in ms)\n @param reply_buffer pointer to reply buffer pointer (free with rados_buffer_free)\n @param reply_buffer_len pointer to size of reply buffer\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_notify(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        timeout_ms: u64,
        reply_buffer: *mut *mut ::std::os::raw::c_char,
        reply_buffer_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_notify2(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        timeout_ms: u64,
        reply_buffer: *mut *mut ::std::os::raw::c_char,
        reply_buffer_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Decode a notify response\n\n Decode a notify response (from rados_aio_notify() call) into acks and\n timeout arrays.\n\n @param reply_buffer buffer from rados_aio_notify() call\n @param reply_buffer_len reply_buffer length\n @param acks pointer to struct notify_ack_t pointer\n @param nr_acks pointer to ack count\n @param timeouts pointer to notify_timeout_t pointer\n @param nr_timeouts pointer to timeout count\n @returns 0 on success"]
    pub fn rados_decode_notify_response(
        reply_buffer: *mut ::std::os::raw::c_char,
        reply_buffer_len: usize,
        acks: *mut *mut notify_ack_t,
        nr_acks: *mut usize,
        timeouts: *mut *mut notify_timeout_t,
        nr_timeouts: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Free notify allocated buffer\n\n Release memory allocated by rados_decode_notify_response() call\n\n @param acks notify_ack_t struct (from rados_decode_notify_response())\n @param nr_acks ack count\n @param timeouts notify_timeout_t struct (from rados_decode_notify_response())"]
    pub fn rados_free_notify_response(
        acks: *mut notify_ack_t,
        nr_acks: usize,
        timeouts: *mut notify_timeout_t,
    );
}
unsafe extern "C" {
    #[doc = " Acknolwedge receipt of a notify\n\n @param io the pool the object is in\n @param o the name of the object\n @param notify_id the notify_id we got on the watchcb2_t callback\n @param cookie the watcher handle\n @param buf payload to return to notifier (optional)\n @param buf_len payload length\n @returns 0 on success"]
    pub fn rados_notify_ack(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        notify_id: u64,
        cookie: u64,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Flush watch/notify callbacks\n\n This call will block until all pending watch/notify callbacks have\n been executed and the queue is empty.  It should usually be called\n after shutting down any watches before shutting down the ioctx or\n librados to ensure that any callbacks do not misuse the ioctx (for\n example by calling rados_notify_ack after the ioctx has been\n destroyed).\n\n @param cluster the cluster handle"]
    pub fn rados_watch_flush(cluster: rados_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Flush watch/notify callbacks\n\n This call will be nonblock, and the completion will be called\n until all pending watch/notify callbacks have been executed and\n the queue is empty.  It should usually be called after shutting\n down any watches before shutting down the ioctx or\n librados to ensure that any callbacks do not misuse the ioctx (for\n example by calling rados_notify_ack after the ioctx has been\n destroyed).\n\n @param cluster the cluster handle\n @param completion what to do when operation has been attempted"]
    pub fn rados_aio_watch_flush(
        cluster: rados_t,
        completion: rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Pin an object in the cache tier\n\n When an object is pinned in the cache tier, it stays in the cache\n tier, and won't be flushed out.\n\n @param io the pool the object is in\n @param o the object id\n @returns 0 on success, negative error code on failure"]
    pub fn rados_cache_pin(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unpin an object in the cache tier\n\n After an object is unpinned in the cache tier, it can be flushed out\n\n @param io the pool the object is in\n @param o the object id\n @returns 0 on success, negative error code on failure"]
    pub fn rados_cache_unpin(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set allocation hint for an object\n\n This is an advisory operation, it will always succeed (as if it was\n submitted with a LIBRADOS_OP_FLAG_FAILOK flag set) and is not\n guaranteed to do anything on the backend.\n\n @param io the pool the object is in\n @param o the name of the object\n @param expected_object_size expected size of the object, in bytes\n @param expected_write_size expected size of writes to the object, in bytes\n @returns 0 on success, negative error code on failure"]
    pub fn rados_set_alloc_hint(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        expected_object_size: u64,
        expected_write_size: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set allocation hint for an object\n\n This is an advisory operation, it will always succeed (as if it was\n submitted with a LIBRADOS_OP_FLAG_FAILOK flag set) and is not\n guaranteed to do anything on the backend.\n\n @param io the pool the object is in\n @param o the name of the object\n @param expected_object_size expected size of the object, in bytes\n @param expected_write_size expected size of writes to the object, in bytes\n @param flags hints about future IO patterns\n @returns 0 on success, negative error code on failure"]
    pub fn rados_set_alloc_hint2(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        expected_object_size: u64,
        expected_write_size: u64,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a new rados_write_op_t write operation. This will store all actions\n to be performed atomically. You must call rados_release_write_op when you are\n finished with it.\n\n @note the ownership of a write operartion is passed to the function\n       performing the operation, so the same instance of @c rados_write_op_t\n       cannot be used again after being performed.\n\n @returns non-NULL on success, NULL on memory allocation error."]
    pub fn rados_create_write_op() -> rados_write_op_t;
}
unsafe extern "C" {
    #[doc = " Free a rados_write_op_t, must be called when you're done with it.\n @param write_op operation to deallocate, created with rados_create_write_op"]
    pub fn rados_release_write_op(write_op: rados_write_op_t);
}
unsafe extern "C" {
    #[doc = " Set flags for the last operation added to this write_op.\n At least one op must have been added to the write_op.\n @param write_op operation to add this action to\n @param flags see librados.h constants beginning with LIBRADOS_OP_FLAG"]
    pub fn rados_write_op_set_flags(write_op: rados_write_op_t, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Ensure that the object exists before writing\n @param write_op operation to add this action to"]
    pub fn rados_write_op_assert_exists(write_op: rados_write_op_t);
}
unsafe extern "C" {
    #[doc = " Ensure that the object exists and that its internal version\n number is equal to \"ver\" before writing. \"ver\" should be a\n version number previously obtained with rados_get_last_version().\n - If the object's version is greater than the asserted version\n   then rados_write_op_operate will return -ERANGE instead of\n   executing the op.\n - If the object's version is less than the asserted version\n   then rados_write_op_operate will return -EOVERFLOW instead\n   of executing the op.\n @param write_op operation to add this action to\n @param ver object version number"]
    pub fn rados_write_op_assert_version(write_op: rados_write_op_t, ver: u64);
}
unsafe extern "C" {
    #[doc = " Ensure that given object range (extent) satisfies comparison.\n\n @param write_op operation to add this action to\n @param cmp_buf buffer containing bytes to be compared with object contents\n @param cmp_len length to compare and size of @c cmp_buf in bytes\n @param off object byte offset at which to start the comparison\n @param prval returned result of comparison, 0 on success, negative error code\n  on failure, (-MAX_ERRNO - mismatch_off) on mismatch"]
    pub fn rados_write_op_cmpext(
        write_op: rados_write_op_t,
        cmp_buf: *const ::std::os::raw::c_char,
        cmp_len: usize,
        off: u64,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Ensure that given xattr satisfies comparison.\n If the comparison is not satisfied, the return code of the\n operation will be -ECANCELED\n @param write_op operation to add this action to\n @param name name of the xattr to look up\n @param comparison_operator currently undocumented, look for\n LIBRADOS_CMPXATTR_OP_EQ in librados.h\n @param value buffer to compare actual xattr value to\n @param value_len length of buffer to compare actual xattr value to"]
    pub fn rados_write_op_cmpxattr(
        write_op: rados_write_op_t,
        name: *const ::std::os::raw::c_char,
        comparison_operator: u8,
        value: *const ::std::os::raw::c_char,
        value_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Ensure that the an omap value satisfies a comparison,\n with the supplied value on the right hand side (i.e.\n for OP_LT, the comparison is actual_value < value.\n\n @param write_op operation to add this action to\n @param key which omap value to compare\n @param comparison_operator one of LIBRADOS_CMPXATTR_OP_EQ,\nLIBRADOS_CMPXATTR_OP_LT, or LIBRADOS_CMPXATTR_OP_GT\n @param val value to compare with\n @param val_len length of value in bytes\n @param prval where to store the return value from this action"]
    pub fn rados_write_op_omap_cmp(
        write_op: rados_write_op_t,
        key: *const ::std::os::raw::c_char,
        comparison_operator: u8,
        val: *const ::std::os::raw::c_char,
        val_len: usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Ensure that the an omap value satisfies a comparison,\n with the supplied value on the right hand side (i.e.\n for OP_LT, the comparison is actual_value < value.\n\n @param write_op operation to add this action to\n @param key which omap value to compare\n @param comparison_operator one of LIBRADOS_CMPXATTR_OP_EQ,\nLIBRADOS_CMPXATTR_OP_LT, or LIBRADOS_CMPXATTR_OP_GT\n @param val value to compare with\n @param key_len length of key in bytes\n @param val_len length of value in bytes\n @param prval where to store the return value from this action"]
    pub fn rados_write_op_omap_cmp2(
        write_op: rados_write_op_t,
        key: *const ::std::os::raw::c_char,
        comparison_operator: u8,
        val: *const ::std::os::raw::c_char,
        key_len: usize,
        val_len: usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Set an xattr\n @param write_op operation to add this action to\n @param name name of the xattr\n @param value buffer to set xattr to\n @param value_len length of buffer to set xattr to"]
    pub fn rados_write_op_setxattr(
        write_op: rados_write_op_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        value_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Remove an xattr\n @param write_op operation to add this action to\n @param name name of the xattr to remove"]
    pub fn rados_write_op_rmxattr(write_op: rados_write_op_t, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Create the object\n @param write_op operation to add this action to\n @param exclusive set to either LIBRADOS_CREATE_EXCLUSIVE or\nLIBRADOS_CREATE_IDEMPOTENT\n will error if the object already exists.\n @param category category string (DEPRECATED, HAS NO EFFECT)"]
    pub fn rados_write_op_create(
        write_op: rados_write_op_t,
        exclusive: ::std::os::raw::c_int,
        category: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Write to offset\n @param write_op operation to add this action to\n @param offset offset to write to\n @param buffer bytes to write\n @param len length of buffer"]
    pub fn rados_write_op_write(
        write_op: rados_write_op_t,
        buffer: *const ::std::os::raw::c_char,
        len: usize,
        offset: u64,
    );
}
unsafe extern "C" {
    #[doc = " Write whole object, atomically replacing it.\n @param write_op operation to add this action to\n @param buffer bytes to write\n @param len length of buffer"]
    pub fn rados_write_op_write_full(
        write_op: rados_write_op_t,
        buffer: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Write the same buffer multiple times\n @param write_op operation to add this action to\n @param buffer bytes to write\n @param data_len length of buffer\n @param write_len total number of bytes to write, as a multiple of @c data_len\n @param offset offset to write to"]
    pub fn rados_write_op_writesame(
        write_op: rados_write_op_t,
        buffer: *const ::std::os::raw::c_char,
        data_len: usize,
        write_len: usize,
        offset: u64,
    );
}
unsafe extern "C" {
    #[doc = " Append to end of object.\n @param write_op operation to add this action to\n @param buffer bytes to write\n @param len length of buffer"]
    pub fn rados_write_op_append(
        write_op: rados_write_op_t,
        buffer: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Remove object\n @param write_op operation to add this action to"]
    pub fn rados_write_op_remove(write_op: rados_write_op_t);
}
unsafe extern "C" {
    #[doc = " Truncate an object\n @param write_op operation to add this action to\n @param offset Offset to truncate to"]
    pub fn rados_write_op_truncate(write_op: rados_write_op_t, offset: u64);
}
unsafe extern "C" {
    #[doc = " Zero part of an object\n @param write_op operation to add this action to\n @param offset Offset to zero\n @param len length to zero"]
    pub fn rados_write_op_zero(write_op: rados_write_op_t, offset: u64, len: u64);
}
unsafe extern "C" {
    #[doc = " Execute an OSD class method on an object\n See rados_exec() for general description.\n\n @param write_op operation to add this action to\n @param cls the name of the class\n @param method the name of the method\n @param in_buf where to find input\n @param in_len length of in_buf in bytes\n @param prval where to store the return value from the method"]
    pub fn rados_write_op_exec(
        write_op: rados_write_op_t,
        cls: *const ::std::os::raw::c_char,
        method: *const ::std::os::raw::c_char,
        in_buf: *const ::std::os::raw::c_char,
        in_len: usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Set key/value pairs on an object\n\n @param write_op operation to add this action to\n @param keys array of null-terminated char arrays representing keys to set\n @param vals array of pointers to values to set\n @param lens array of lengths corresponding to each value\n @param num number of key/value pairs to set"]
    pub fn rados_write_op_omap_set(
        write_op: rados_write_op_t,
        keys: *const *const ::std::os::raw::c_char,
        vals: *const *const ::std::os::raw::c_char,
        lens: *const usize,
        num: usize,
    );
}
unsafe extern "C" {
    #[doc = " Set key/value pairs on an object\n\n @param write_op operation to add this action to\n @param keys array of null-terminated char arrays representing keys to set\n @param vals array of pointers to values to set\n @param key_lens array of lengths corresponding to each key\n @param val_lens array of lengths corresponding to each value\n @param num number of key/value pairs to set"]
    pub fn rados_write_op_omap_set2(
        write_op: rados_write_op_t,
        keys: *const *const ::std::os::raw::c_char,
        vals: *const *const ::std::os::raw::c_char,
        key_lens: *const usize,
        val_lens: *const usize,
        num: usize,
    );
}
unsafe extern "C" {
    #[doc = " Remove key/value pairs from an object\n\n @param write_op operation to add this action to\n @param keys array of null-terminated char arrays representing keys to remove\n @param keys_len number of key/value pairs to remove"]
    pub fn rados_write_op_omap_rm_keys(
        write_op: rados_write_op_t,
        keys: *const *const ::std::os::raw::c_char,
        keys_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Remove key/value pairs from an object\n\n @param write_op operation to add this action to\n @param keys array of char arrays representing keys to remove\n @param key_lens array of size_t values representing length of each key\n @param keys_len number of key/value pairs to remove"]
    pub fn rados_write_op_omap_rm_keys2(
        write_op: rados_write_op_t,
        keys: *const *const ::std::os::raw::c_char,
        key_lens: *const usize,
        keys_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Remove key/value pairs from an object whose keys are in the range\n [key_begin, key_end)\n\n @param write_op operation to add this action to\n @param key_begin the lower bound of the key range to remove\n @param key_begin_len length of key_begin\n @param key_end the upper bound of the key range to remove\n @param key_end_len length of key_end"]
    pub fn rados_write_op_omap_rm_range2(
        write_op: rados_write_op_t,
        key_begin: *const ::std::os::raw::c_char,
        key_begin_len: usize,
        key_end: *const ::std::os::raw::c_char,
        key_end_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Remove all key/value pairs from an object\n\n @param write_op operation to add this action to"]
    pub fn rados_write_op_omap_clear(write_op: rados_write_op_t);
}
unsafe extern "C" {
    #[doc = " Set allocation hint for an object\n\n @param write_op operation to add this action to\n @param expected_object_size expected size of the object, in bytes\n @param expected_write_size expected size of writes to the object, in bytes"]
    pub fn rados_write_op_set_alloc_hint(
        write_op: rados_write_op_t,
        expected_object_size: u64,
        expected_write_size: u64,
    );
}
unsafe extern "C" {
    #[doc = " Set allocation hint for an object\n\n @param write_op operation to add this action to\n @param expected_object_size expected size of the object, in bytes\n @param expected_write_size expected size of writes to the object, in bytes\n @param flags hints about future IO patterns"]
    pub fn rados_write_op_set_alloc_hint2(
        write_op: rados_write_op_t,
        expected_object_size: u64,
        expected_write_size: u64,
        flags: u32,
    );
}
unsafe extern "C" {
    #[doc = " Perform a write operation synchronously\n @param write_op operation to perform\n @param io the ioctx that the object is in\n @param oid the object id\n @param mtime the time to set the mtime to, NULL for the current time\n @param flags flags to apply to the entire operation (LIBRADOS_OPERATION_*)"]
    pub fn rados_write_op_operate(
        write_op: rados_write_op_t,
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        mtime: *mut time_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a write operation synchronously\n @param write_op operation to perform\n @param io the ioctx that the object is in\n @param oid the object id\n @param mtime the time to set the mtime to, NULL for the current time\n @param flags flags to apply to the entire operation (LIBRADOS_OPERATION_*)"]
    pub fn rados_write_op_operate2(
        write_op: rados_write_op_t,
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        mtime: *mut timespec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a write operation asynchronously\n @param write_op operation to perform\n @param io the ioctx that the object is in\n @param completion what to do when operation has been attempted\n @param oid the object id\n @param mtime the time to set the mtime to, NULL for the current time\n @param flags flags to apply to the entire operation (LIBRADOS_OPERATION_*)"]
    pub fn rados_aio_write_op_operate(
        write_op: rados_write_op_t,
        io: rados_ioctx_t,
        completion: rados_completion_t,
        oid: *const ::std::os::raw::c_char,
        mtime: *mut time_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a write operation asynchronously\n @param write_op operation to perform\n @param io the ioctx that the object is in\n @param completion what to do when operation has been attempted\n @param oid the object id\n @param mtime the time to set the mtime to, NULL for the current time\n @param flags flags to apply to the entire operation (LIBRADOS_OPERATION_*)"]
    pub fn rados_aio_write_op_operate2(
        write_op: rados_write_op_t,
        io: rados_ioctx_t,
        completion: rados_completion_t,
        oid: *const ::std::os::raw::c_char,
        mtime: *mut timespec,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a new rados_read_op_t read operation. This will store all\n actions to be performed atomically. You must call\n rados_release_read_op when you are finished with it (after it\n completes, or you decide not to send it in the first place).\n\n @note the ownership of a read operartion is passed to the function\n       performing the operation, so the same instance of @c rados_read_op_t\n       cannot be used again after being performed.\n\n @returns non-NULL on success, NULL on memory allocation error."]
    pub fn rados_create_read_op() -> rados_read_op_t;
}
unsafe extern "C" {
    #[doc = " Free a rados_read_op_t, must be called when you're done with it.\n @param read_op operation to deallocate, created with rados_create_read_op"]
    pub fn rados_release_read_op(read_op: rados_read_op_t);
}
unsafe extern "C" {
    #[doc = " Set flags for the last operation added to this read_op.\n At least one op must have been added to the read_op.\n @param read_op operation to add this action to\n @param flags see librados.h constants beginning with LIBRADOS_OP_FLAG"]
    pub fn rados_read_op_set_flags(read_op: rados_read_op_t, flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Ensure that the object exists before reading\n @param read_op operation to add this action to"]
    pub fn rados_read_op_assert_exists(read_op: rados_read_op_t);
}
unsafe extern "C" {
    #[doc = " Ensure that the object exists and that its internal version\n number is equal to \"ver\" before reading. \"ver\" should be a\n version number previously obtained with rados_get_last_version().\n - If the object's version is greater than the asserted version\n   then rados_read_op_operate will return -ERANGE instead of\n   executing the op.\n - If the object's version is less than the asserted version\n   then rados_read_op_operate will return -EOVERFLOW instead\n   of executing the op.\n @param read_op operation to add this action to\n @param ver object version number"]
    pub fn rados_read_op_assert_version(read_op: rados_read_op_t, ver: u64);
}
unsafe extern "C" {
    #[doc = " Ensure that given object range (extent) satisfies comparison.\n\n @param read_op operation to add this action to\n @param cmp_buf buffer containing bytes to be compared with object contents\n @param cmp_len length to compare and size of @c cmp_buf in bytes\n @param off object byte offset at which to start the comparison\n @param prval returned result of comparison, 0 on success, negative error code\n  on failure, (-MAX_ERRNO - mismatch_off) on mismatch"]
    pub fn rados_read_op_cmpext(
        read_op: rados_read_op_t,
        cmp_buf: *const ::std::os::raw::c_char,
        cmp_len: usize,
        off: u64,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Ensure that the an xattr satisfies a comparison\n If the comparison is not satisfied, the return code of the\n operation will be -ECANCELED\n @param read_op operation to add this action to\n @param name name of the xattr to look up\n @param comparison_operator currently undocumented, look for\n LIBRADOS_CMPXATTR_OP_EQ in librados.h\n @param value buffer to compare actual xattr value to\n @param value_len length of buffer to compare actual xattr value to"]
    pub fn rados_read_op_cmpxattr(
        read_op: rados_read_op_t,
        name: *const ::std::os::raw::c_char,
        comparison_operator: u8,
        value: *const ::std::os::raw::c_char,
        value_len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over xattrs on an object.\n\n @param read_op operation to add this action to\n @param iter where to store the iterator\n @param prval where to store the return value of this action"]
    pub fn rados_read_op_getxattrs(
        read_op: rados_read_op_t,
        iter: *mut rados_xattrs_iter_t,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Ensure that the an omap value satisfies a comparison,\n with the supplied value on the right hand side (i.e.\n for OP_LT, the comparison is actual_value < value.\n\n @param read_op operation to add this action to\n @param key which omap value to compare\n @param comparison_operator one of LIBRADOS_CMPXATTR_OP_EQ,\nLIBRADOS_CMPXATTR_OP_LT, or LIBRADOS_CMPXATTR_OP_GT\n @param val value to compare with\n @param val_len length of value in bytes\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_cmp(
        read_op: rados_read_op_t,
        key: *const ::std::os::raw::c_char,
        comparison_operator: u8,
        val: *const ::std::os::raw::c_char,
        val_len: usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Ensure that the an omap value satisfies a comparison,\n with the supplied value on the right hand side (i.e.\n for OP_LT, the comparison is actual_value < value.\n\n @param read_op operation to add this action to\n @param key which omap value to compare\n @param comparison_operator one of LIBRADOS_CMPXATTR_OP_EQ,\nLIBRADOS_CMPXATTR_OP_LT, or LIBRADOS_CMPXATTR_OP_GT\n @param val value to compare with\n @param key_len length of key in bytes\n @param val_len length of value in bytes\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_cmp2(
        read_op: rados_read_op_t,
        key: *const ::std::os::raw::c_char,
        comparison_operator: u8,
        val: *const ::std::os::raw::c_char,
        key_len: usize,
        val_len: usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Get object size and mtime\n @param read_op operation to add this action to\n @param psize where to store object size\n @param pmtime where to store modification time\n @param prval where to store the return value of this action"]
    pub fn rados_read_op_stat(
        read_op: rados_read_op_t,
        psize: *mut u64,
        pmtime: *mut time_t,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn rados_read_op_stat2(
        read_op: rados_read_op_t,
        psize: *mut u64,
        pmtime: *mut timespec,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Read bytes from offset into buffer.\n\n prlen will be filled with the number of bytes read if successful.\n A short read can only occur if the read reaches the end of the\n object.\n\n @param read_op operation to add this action to\n @param offset offset to read from\n @param len length of buffer\n @param buffer where to put the data\n @param bytes_read where to store the number of bytes read by this action\n @param prval where to store the return value of this action"]
    pub fn rados_read_op_read(
        read_op: rados_read_op_t,
        offset: u64,
        len: usize,
        buffer: *mut ::std::os::raw::c_char,
        bytes_read: *mut usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Compute checksum from object data\n\n @param read_op operation to add this action to\n @param type the checksum algorithm to utilize\n @param init_value the init value for the algorithm\n @param init_value_len the length of the init value\n @param offset the offset to start checksumming in the object\n @param len the number of bytes to checksum\n @param chunk_size optional length-aligned chunk size for checksums\n @param pchecksum where to store the checksum result for this action\n @param checksum_len the number of bytes available for the result\n @param prval where to store the return value for this action"]
    pub fn rados_read_op_checksum(
        read_op: rados_read_op_t,
        type_: rados_checksum_type_t,
        init_value: *const ::std::os::raw::c_char,
        init_value_len: usize,
        offset: u64,
        len: usize,
        chunk_size: usize,
        pchecksum: *mut ::std::os::raw::c_char,
        checksum_len: usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Execute an OSD class method on an object\n See rados_exec() for general description.\n\n The output buffer is allocated on the heap; the caller is\n expected to release that memory with rados_buffer_free(). The\n buffer and length pointers can all be NULL, in which case they are\n not filled in.\n\n @param read_op operation to add this action to\n @param cls the name of the class\n @param method the name of the method\n @param in_buf where to find input\n @param in_len length of in_buf in bytes\n @param out_buf where to put librados-allocated output buffer\n @param out_len length of out_buf in bytes\n @param prval where to store the return value from the method"]
    pub fn rados_read_op_exec(
        read_op: rados_read_op_t,
        cls: *const ::std::os::raw::c_char,
        method: *const ::std::os::raw::c_char,
        in_buf: *const ::std::os::raw::c_char,
        in_len: usize,
        out_buf: *mut *mut ::std::os::raw::c_char,
        out_len: *mut usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Execute an OSD class method on an object\n See rados_exec() for general description.\n\n If the output buffer is too small, prval will\n be set to -ERANGE and used_len will be 0.\n\n @param read_op operation to add this action to\n @param cls the name of the class\n @param method the name of the method\n @param in_buf where to find input\n @param in_len length of in_buf in bytes\n @param out_buf user-provided buffer to read into\n @param out_len length of out_buf in bytes\n @param used_len where to store the number of bytes read into out_buf\n @param prval where to store the return value from the method"]
    pub fn rados_read_op_exec_user_buf(
        read_op: rados_read_op_t,
        cls: *const ::std::os::raw::c_char,
        method: *const ::std::os::raw::c_char,
        in_buf: *const ::std::os::raw::c_char,
        in_len: usize,
        out_buf: *mut ::std::os::raw::c_char,
        out_len: usize,
        used_len: *mut usize,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over key/value pairs on an object.\n\n They will be returned sorted by key.\n\n @param read_op operation to add this action to\n @param start_after list keys starting after start_after\n @param filter_prefix list only keys beginning with filter_prefix\n @param max_return list no more than max_return key/value pairs\n @param iter where to store the iterator\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_get_vals(
        read_op: rados_read_op_t,
        start_after: *const ::std::os::raw::c_char,
        filter_prefix: *const ::std::os::raw::c_char,
        max_return: u64,
        iter: *mut rados_omap_iter_t,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over key/value pairs on an object.\n\n They will be returned sorted by key.\n\n @param read_op operation to add this action to\n @param start_after list keys starting after start_after\n @param filter_prefix list only keys beginning with filter_prefix\n @param max_return list no more than max_return key/value pairs\n @param iter where to store the iterator\n @param pmore flag indicating whether there are more keys to fetch\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_get_vals2(
        read_op: rados_read_op_t,
        start_after: *const ::std::os::raw::c_char,
        filter_prefix: *const ::std::os::raw::c_char,
        max_return: u64,
        iter: *mut rados_omap_iter_t,
        pmore: *mut ::std::os::raw::c_uchar,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over keys on an object.\n\n They will be returned sorted by key, and the iterator\n will fill in NULL for all values if specified.\n\n @param read_op operation to add this action to\n @param start_after list keys starting after start_after\n @param max_return list no more than max_return keys\n @param iter where to store the iterator\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_get_keys(
        read_op: rados_read_op_t,
        start_after: *const ::std::os::raw::c_char,
        max_return: u64,
        iter: *mut rados_omap_iter_t,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over keys on an object.\n\n They will be returned sorted by key, and the iterator\n will fill in NULL for all values if specified.\n\n @param read_op operation to add this action to\n @param start_after list keys starting after start_after\n @param max_return list no more than max_return keys\n @param iter where to store the iterator\n @param pmore flag indicating whether there are more keys to fetch\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_get_keys2(
        read_op: rados_read_op_t,
        start_after: *const ::std::os::raw::c_char,
        max_return: u64,
        iter: *mut rados_omap_iter_t,
        pmore: *mut ::std::os::raw::c_uchar,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over specific key/value pairs\n\n They will be returned sorted by key.\n\n @param read_op operation to add this action to\n @param keys array of pointers to null-terminated keys to get\n @param keys_len the number of strings in keys\n @param iter where to store the iterator\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_get_vals_by_keys(
        read_op: rados_read_op_t,
        keys: *const *const ::std::os::raw::c_char,
        keys_len: usize,
        iter: *mut rados_omap_iter_t,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Start iterating over specific key/value pairs\n\n They will be returned sorted by key.\n\n @param read_op operation to add this action to\n @param keys array of pointers to keys to get\n @param num_keys the number of strings in keys\n @param key_lens array of size_t's describing each key len (in bytes)\n @param iter where to store the iterator\n @param prval where to store the return value from this action"]
    pub fn rados_read_op_omap_get_vals_by_keys2(
        read_op: rados_read_op_t,
        keys: *const *const ::std::os::raw::c_char,
        num_keys: usize,
        key_lens: *const usize,
        iter: *mut rados_omap_iter_t,
        prval: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Perform a read operation synchronously\n @param read_op operation to perform\n @param io the ioctx that the object is in\n @param oid the object id\n @param flags flags to apply to the entire operation (LIBRADOS_OPERATION_*)"]
    pub fn rados_read_op_operate(
        read_op: rados_read_op_t,
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Perform a read operation asynchronously\n @param read_op operation to perform\n @param io the ioctx that the object is in\n @param completion what to do when operation has been attempted\n @param oid the object id\n @param flags flags to apply to the entire operation (LIBRADOS_OPERATION_*)"]
    pub fn rados_aio_read_op_operate(
        read_op: rados_read_op_t,
        io: rados_ioctx_t,
        completion: rados_completion_t,
        oid: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Take an exclusive lock on an object.\n\n @param io the context to operate in\n @param oid the name of the object\n @param name the name of the lock\n @param cookie user-defined identifier for this instance of the lock\n @param desc user-defined lock description\n @param duration the duration of the lock. Set to NULL for infinite duration.\n @param flags lock flags\n @returns 0 on success, negative error code on failure\n @returns -EBUSY if the lock is already held by another (client, cookie) pair\n @returns -EEXIST if the lock is already held by the same (client, cookie) pair"]
    pub fn rados_lock_exclusive(
        io: rados_ioctx_t,
        oid: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        cookie: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        duration: *mut timeval,
        flags: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Take a shared lock on an object.\n\n @param io the context to operate in\n @param o the name of the object\n @param name the name of the lock\n @param cookie user-defined identifier for this instance of the lock\n @param tag The tag of the lock\n @param desc user-defined lock description\n @param duration the duration of the lock. Set to NULL for infinite duration.\n @param flags lock flags\n @returns 0 on success, negative error code on failure\n @returns -EBUSY if the lock is already held by another (client, cookie) pair\n @returns -EEXIST if the lock is already held by the same (client, cookie) pair"]
    pub fn rados_lock_shared(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        cookie: *const ::std::os::raw::c_char,
        tag: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        duration: *mut timeval,
        flags: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release a shared or exclusive lock on an object.\n\n @param io the context to operate in\n @param o the name of the object\n @param name the name of the lock\n @param cookie user-defined identifier for the instance of the lock\n @returns 0 on success, negative error code on failure\n @returns -ENOENT if the lock is not held by the specified (client, cookie) pair"]
    pub fn rados_unlock(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        cookie: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Asynchronous release a shared or exclusive lock on an object.\n\n @param io the context to operate in\n @param o the name of the object\n @param name the name of the lock\n @param cookie user-defined identifier for the instance of the lock\n @param completion what to do when operation has been attempted\n @returns 0 on success, negative error code on failure"]
    pub fn rados_aio_unlock(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        cookie: *const ::std::os::raw::c_char,
        completion: rados_completion_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List clients that have locked the named object lock and information about\n the lock.\n\n The number of bytes required in each buffer is put in the\n corresponding size out parameter. If any of the provided buffers\n are too short, -ERANGE is returned after these sizes are filled in.\n\n @param io the context to operate in\n @param o the name of the object\n @param name the name of the lock\n @param exclusive where to store whether the lock is exclusive (1) or shared (0)\n @param tag where to store the tag associated with the object lock\n @param tag_len number of bytes in tag buffer\n @param clients buffer in which locker clients are stored, separated by '\\0'\n @param clients_len number of bytes in the clients buffer\n @param cookies buffer in which locker cookies are stored, separated by '\\0'\n @param cookies_len number of bytes in the cookies buffer\n @param addrs buffer in which locker addresses are stored, separated by '\\0'\n @param addrs_len number of bytes in the clients buffer\n @returns number of lockers on success, negative error code on failure\n @returns -ERANGE if any of the buffers are too short"]
    pub fn rados_list_lockers(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exclusive: *mut ::std::os::raw::c_int,
        tag: *mut ::std::os::raw::c_char,
        tag_len: *mut usize,
        clients: *mut ::std::os::raw::c_char,
        clients_len: *mut usize,
        cookies: *mut ::std::os::raw::c_char,
        cookies_len: *mut usize,
        addrs: *mut ::std::os::raw::c_char,
        addrs_len: *mut usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = " Releases a shared or exclusive lock on an object, which was taken by the\n specified client.\n\n @param io the context to operate in\n @param o the name of the object\n @param name the name of the lock\n @param client the client currently holding the lock\n @param cookie user-defined identifier for the instance of the lock\n @returns 0 on success, negative error code on failure\n @returns -ENOENT if the lock is not held by the specified (client, cookie) pair\n @returns -EINVAL if the client cannot be parsed"]
    pub fn rados_break_lock(
        io: rados_ioctx_t,
        o: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        client: *const ::std::os::raw::c_char,
        cookie: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Blocklists the specified client from the OSDs\n\n @param cluster cluster handle\n @param client_address client address\n @param expire_seconds number of seconds to blocklist (0 for default)\n @returns 0 on success, negative error code on failure"]
    pub fn rados_blocklist_add(
        cluster: rados_t,
        client_address: *mut ::std::os::raw::c_char,
        expire_seconds: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_blacklist_add(
        cluster: rados_t,
        client_address: *mut ::std::os::raw::c_char,
        expire_seconds: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets addresses of the RADOS session, suitable for blocklisting.\n\n @param cluster cluster handle\n @param addrs the output string.\n @returns 0 on success, negative error code on failure"]
    pub fn rados_getaddrs(
        cluster: rados_t,
        addrs: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_set_osdmap_full_try(io: rados_ioctx_t);
}
unsafe extern "C" {
    pub fn rados_unset_osdmap_full_try(io: rados_ioctx_t);
}
unsafe extern "C" {
    pub fn rados_set_pool_full_try(io: rados_ioctx_t);
}
unsafe extern "C" {
    pub fn rados_unset_pool_full_try(io: rados_ioctx_t);
}
unsafe extern "C" {
    #[doc = " Enable an application on a pool\n\n @param io pool ioctx\n @param app_name application name\n @param force 0 if only single application per pool\n @returns 0 on success, negative error code on failure"]
    pub fn rados_application_enable(
        io: rados_ioctx_t,
        app_name: *const ::std::os::raw::c_char,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List all enabled applications\n\n If the provided buffer is too short, the required length is filled in and\n -ERANGE is returned. Otherwise, the buffers are filled with the application\n names, with a '\\0' after each.\n\n @param io pool ioctx\n @param values buffer in which to store application names\n @param values_len number of bytes in values buffer\n @returns 0 on success, negative error code on failure\n @returns -ERANGE if either buffer is too short"]
    pub fn rados_application_list(
        io: rados_ioctx_t,
        values: *mut ::std::os::raw::c_char,
        values_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get application metadata value from pool\n\n @param io pool ioctx\n @param app_name application name\n @param key metadata key\n @param value result buffer\n @param value_len maximum len of value\n @returns 0 on success, negative error code on failure"]
    pub fn rados_application_metadata_get(
        io: rados_ioctx_t,
        app_name: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        value_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set application metadata on a pool\n\n @param io pool ioctx\n @param app_name application name\n @param key metadata key\n @param value metadata key\n @returns 0 on success, negative error code on failure"]
    pub fn rados_application_metadata_set(
        io: rados_ioctx_t,
        app_name: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove application metadata from a pool\n\n @param io pool ioctx\n @param app_name application name\n @param key metadata key\n @returns 0 on success, negative error code on failure"]
    pub fn rados_application_metadata_remove(
        io: rados_ioctx_t,
        app_name: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " List all metadata key/value pairs associated with an application.\n\n This iterates over all metadata, key_len and val_len are filled in\n with the number of bytes put into the keys and values buffers.\n\n If the provided buffers are too short, the required lengths are filled\n in and -ERANGE is returned. Otherwise, the buffers are filled with\n the keys and values of the metadata, with a '\\0' after each.\n\n @param io pool ioctx\n @param app_name application name\n @param keys buffer in which to store key names\n @param key_len number of bytes in keys buffer\n @param values buffer in which to store values\n @param vals_len number of bytes in values buffer\n @returns 0 on success, negative error code on failure\n @returns -ERANGE if either buffer is too short"]
    pub fn rados_application_metadata_list(
        io: rados_ioctx_t,
        app_name: *const ::std::os::raw::c_char,
        keys: *mut ::std::os::raw::c_char,
        key_len: *mut usize,
        values: *mut ::std::os::raw::c_char,
        vals_len: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Send monitor command.\n\n @note Takes command string in carefully-formatted JSON; must match\n defined commands, types, etc.\n\n The result buffers are allocated on the heap; the caller is\n expected to release that memory with rados_buffer_free().  The\n buffer and length pointers can all be NULL, in which case they are\n not filled in.\n\n @param cluster cluster handle\n @param cmd an array of char *'s representing the command\n @param cmdlen count of valid entries in cmd\n @param inbuf any bulk input data (crush map, etc.)\n @param inbuflen input buffer length\n @param outbuf double pointer to output buffer\n @param outbuflen pointer to output buffer length\n @param outs double pointer to status string\n @param outslen pointer to status string length\n @returns 0 on success, negative error code on failure"]
    pub fn rados_mon_command(
        cluster: rados_t,
        cmd: *mut *const ::std::os::raw::c_char,
        cmdlen: usize,
        inbuf: *const ::std::os::raw::c_char,
        inbuflen: usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbuflen: *mut usize,
        outs: *mut *mut ::std::os::raw::c_char,
        outslen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Send ceph-mgr command.\n\n @note Takes command string in carefully-formatted JSON; must match\n defined commands, types, etc.\n\n The result buffers are allocated on the heap; the caller is\n expected to release that memory with rados_buffer_free().  The\n buffer and length pointers can all be NULL, in which case they are\n not filled in.\n\n @param cluster cluster handle\n @param cmd an array of char *'s representing the command\n @param cmdlen count of valid entries in cmd\n @param inbuf any bulk input data (crush map, etc.)\n @param inbuflen input buffer length\n @param outbuf double pointer to output buffer\n @param outbuflen pointer to output buffer length\n @param outs double pointer to status string\n @param outslen pointer to status string length\n @returns 0 on success, negative error code on failure"]
    pub fn rados_mgr_command(
        cluster: rados_t,
        cmd: *mut *const ::std::os::raw::c_char,
        cmdlen: usize,
        inbuf: *const ::std::os::raw::c_char,
        inbuflen: usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbuflen: *mut usize,
        outs: *mut *mut ::std::os::raw::c_char,
        outslen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Send ceph-mgr tell command.\n\n @note Takes command string in carefully-formatted JSON; must match\n defined commands, types, etc.\n\n The result buffers are allocated on the heap; the caller is\n expected to release that memory with rados_buffer_free().  The\n buffer and length pointers can all be NULL, in which case they are\n not filled in.\n\n @param cluster cluster handle\n @param name mgr name to target\n @param cmd an array of char *'s representing the command\n @param cmdlen count of valid entries in cmd\n @param inbuf any bulk input data (crush map, etc.)\n @param inbuflen input buffer length\n @param outbuf double pointer to output buffer\n @param outbuflen pointer to output buffer length\n @param outs double pointer to status string\n @param outslen pointer to status string length\n @returns 0 on success, negative error code on failure"]
    pub fn rados_mgr_command_target(
        cluster: rados_t,
        name: *const ::std::os::raw::c_char,
        cmd: *mut *const ::std::os::raw::c_char,
        cmdlen: usize,
        inbuf: *const ::std::os::raw::c_char,
        inbuflen: usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbuflen: *mut usize,
        outs: *mut *mut ::std::os::raw::c_char,
        outslen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Send monitor command to a specific monitor.\n\n @note Takes command string in carefully-formatted JSON; must match\n defined commands, types, etc.\n\n The result buffers are allocated on the heap; the caller is\n expected to release that memory with rados_buffer_free().  The\n buffer and length pointers can all be NULL, in which case they are\n not filled in.\n\n @param cluster cluster handle\n @param name target monitor's name\n @param cmd an array of char *'s representing the command\n @param cmdlen count of valid entries in cmd\n @param inbuf any bulk input data (crush map, etc.)\n @param inbuflen input buffer length\n @param outbuf double pointer to output buffer\n @param outbuflen pointer to output buffer length\n @param outs double pointer to status string\n @param outslen pointer to status string length\n @returns 0 on success, negative error code on failure"]
    pub fn rados_mon_command_target(
        cluster: rados_t,
        name: *const ::std::os::raw::c_char,
        cmd: *mut *const ::std::os::raw::c_char,
        cmdlen: usize,
        inbuf: *const ::std::os::raw::c_char,
        inbuflen: usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbuflen: *mut usize,
        outs: *mut *mut ::std::os::raw::c_char,
        outslen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " free a rados-allocated buffer\n\n Release memory allocated by librados calls like rados_mon_command().\n\n @param buf buffer pointer"]
    pub fn rados_buffer_free(buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn rados_osd_command(
        cluster: rados_t,
        osdid: ::std::os::raw::c_int,
        cmd: *mut *const ::std::os::raw::c_char,
        cmdlen: usize,
        inbuf: *const ::std::os::raw::c_char,
        inbuflen: usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbuflen: *mut usize,
        outs: *mut *mut ::std::os::raw::c_char,
        outslen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_pg_command(
        cluster: rados_t,
        pgstr: *const ::std::os::raw::c_char,
        cmd: *mut *const ::std::os::raw::c_char,
        cmdlen: usize,
        inbuf: *const ::std::os::raw::c_char,
        inbuflen: usize,
        outbuf: *mut *mut ::std::os::raw::c_char,
        outbuflen: *mut usize,
        outs: *mut *mut ::std::os::raw::c_char,
        outslen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub type rados_log_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        line: *const ::std::os::raw::c_char,
        who: *const ::std::os::raw::c_char,
        sec: u64,
        nsec: u64,
        seq: u64,
        level: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ),
>;
pub type rados_log_callback2_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        line: *const ::std::os::raw::c_char,
        channel: *const ::std::os::raw::c_char,
        who: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        sec: u64,
        nsec: u64,
        seq: u64,
        level: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ),
>;
unsafe extern "C" {
    pub fn rados_monitor_log(
        cluster: rados_t,
        level: *const ::std::os::raw::c_char,
        cb: rados_log_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_monitor_log2(
        cluster: rados_t,
        level: *const ::std::os::raw::c_char,
        cb: rados_log_callback2_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " register daemon instance for a service\n\n Register us as a daemon providing a particular service.  We identify\n the service (e.g., 'rgw') and our instance name (e.g., 'rgw.$hostname').\n The metadata is a map of keys and values with arbitrary static metdata\n for this instance.  The encoding is a series of NULL-terminated strings,\n alternating key names and values, terminating with an empty key name.\n For example,  \"foo\\0bar\\0this\\0that\\0\\0\" is the dict {foo=bar,this=that}.\n\n For the lifetime of the librados instance, regular beacons will be sent\n to the cluster to maintain our registration in the service map.\n\n @param cluster handle\n @param service service name\n @param daemon daemon instance name\n @param metadata_dict static daemon metadata dict"]
    pub fn rados_service_register(
        cluster: rados_t,
        service: *const ::std::os::raw::c_char,
        daemon: *const ::std::os::raw::c_char,
        metadata_dict: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " update daemon status\n\n Update our mutable status information in the service map.\n\n The status dict is encoded the same way the daemon metadata is encoded\n for rados_service_register.  For example, \"foo\\0bar\\0this\\0that\\0\\0\" is\n {foo=bar,this=that}.\n\n @param cluster rados cluster handle\n @param status_dict status dict"]
    pub fn rados_service_update_status(
        cluster: rados_t,
        status_dict: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @} Mon/OSD/PG commands"]
    pub fn rados_objects_list_open(
        io: rados_ioctx_t,
        ctx: *mut rados_list_ctx_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_objects_list_get_pg_hash_position(ctx: rados_list_ctx_t) -> u32;
}
unsafe extern "C" {
    pub fn rados_objects_list_seek(ctx: rados_list_ctx_t, pos: u32) -> u32;
}
unsafe extern "C" {
    pub fn rados_objects_list_next(
        ctx: rados_list_ctx_t,
        entry: *mut *const ::std::os::raw::c_char,
        key: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rados_objects_list_close(ctx: rados_list_ctx_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
